<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="author" content="slene, Unknown">

<title>beego API开发以及自动化文档 - beego: 简约 &amp; 强大并存的 Go 应用框架</title>




<script>/* Beego Compress group `lib` begin */</script>
	<link rel="stylesheet" href="static/css/bootstrap-1409586500.css">
	<link rel="stylesheet" href="static/css/bootstrap-theme-1409586500.css">
	<link rel="stylesheet" href="static/css/font-awesome.min-1409586500.css">
	<link rel="stylesheet" href="static/css/prettify-1409586500.css">
	<link rel="stylesheet" href="static/css/select2-1409586500.css">
	<script>/* end */</script>
<!--[if IE 7]>
<script>/* Beego Compress group `ie7` begin */</script>
	<link rel="stylesheet" href="/static_source/css/font-awesome-ie7.min.css?ver=1409586500" />
	<script>/* end */</script>
<![endif]-->
<script>/* Beego Compress group `app` begin */</script>
	<link rel="stylesheet" href="static/css/base-1409586500.css">
	<link rel="stylesheet" href="static/css/markdown-1409586500.css">
	<link rel="stylesheet" href="static/css/main-1409586500.css">
	<script>/* end */</script>

<!--[if lt IE 9]>
	<script>/* Beego Compress group `ie9` begin */</script>
	<script type="text/javascript" src="/static_source/js/html5shiv.js?ver=1409586500"></script>
	<script type="text/javascript" src="/static_source/js/respond.min.js?ver=1409586500"></script>
	<script>/* end */</script>
<![endif]-->
		
	</head>
	<body id="front">
		<noscript>请启用您浏览器的 JavaScript 选项！</noscript>
		<div id="wrapper">
			<nav class="navbar navbar-default navbar-fixed-top">
    <div class="container" data-toggle="clingify">
        <div class="row">
            <div class="navbar-header">
                
                <a type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar-collapse">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </a>
                <a class="hidden-xs logo" href="index.html">
                    <img style="height:32px;width:102px;" src="static/picture/beego_purple.png">
                </a>
                <div class="visible-xs text-center">
                    <a class="navbar-brand" href="index.html">
                        Beego
                    </a>
                    
                    <span class="nav-github">
                        <span rel="show-github" data-user="astaxie" data-repo="beego"></span>
                    </span>
                    
                </div>
            </div>
            <div class="collapse navbar-collapse" role="navigation" id="navbar-collapse">
                <ul class="nav navbar-nav">
                    <li><a href="index.html">首页</a></li>
                    <li><a href="quickstart.html">快速入门</a></li>
                    <li><a href="community.html">开发者社区</a></li>
                    <li><a href="index1.html">开发文档</a></li>
                    <li><a href="video.html">视频教程</a></li>
                    <li><a href="products.html">产品案例</a></li>
                    <li class="active"><a href="blog.html">官方博客</a></li>
                </ul>
                <div class="hidden-sm hidden-xs nav-lang pull-right">
                    <div class="btn-group">
                        <button type="button" class="btn btn-xs btn-default btn-md dropdown-toggle" data-toggle="dropdown">当前语言:简体中文 <i class="caret"></i></button>
                        <ul class="dropdown-menu">
                            
                                <li><a href="javascript::" data-lang="en-US" class="lang-changed">English</a></li>
                            
                                <li><a href="javascript::" data-lang="ru-RU" class="lang-changed">Russian</a></li>
                            
                        </ul>
                    </div>
                </div>
                <div class="hidden-sm hidden-xs nav-github pull-right">
                    <span rel="show-github" data-user="astaxie" data-repo="beego"></span>
                    <span rel="show-github" data-user="astaxie" data-repo="beego" data-type="fork"></span>
                </div>
            </div>
        </div>
    </div>
</nav>
			<div id="main">
				
<div class="container main-container">
	<div class="row">
		<div class="col-md-12">
			<div class="box">
				<div class="cell slim page-box markdown">
					<div class="page-header">
					    <h1>
					    	beego API开发以及自动化文档
					    </h1>
					</div>
					<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title></title>
  <meta name="GENERATOR" content="Blackfriday Markdown Processor v1.1">
  <meta charset="utf-8">
</head>
<body>

<p>eego1.3版本已经在上个星期发布了，但是还是有很多人不了解如何来进行开发，也是在一步一步的测试中开发，期间QQ群里面很多人都问我如何开发，我的业余时间实在是排的太满了，实在是没办法一一回复大家，在这里和大家说声对不起，这两天我又不断的改进，写了一个应用示例展示如何使用beego开发API已经自动化文档和测试，这里就和大家详细的解说一下。</p>

<h2>自动化文档开发的初衷</h2>

<p>我们需要开发一个API应用，然后需要和手机组的开发人员一起合作，当然我们首先想到的是文档先行，我们也根据之前的经验写了我们需要的API原型文档，我们还是根据github的文档格式写了一些漂亮的文档，但是我们开始担心这个文档如果两边不同步怎么办？因为毕竟是原型文档，变动是必不可少的。手机组有一个同事之前在雅虎工作过，他推荐我看一个swagger的应用，看了swagger的标准和文档化的要求，感觉太棒了，这个简直就是神器啊，通过swagger可以方便的查看API的文档，同时使用API的用户可以直接通过swagger进行请求和获取结果。所以我就开始学习swagger的标准，同时开始进行Go源码的研究，通过Go里面的AST进行源码分析，针对comments解析，然后生成swagger标准的json格式，这样最后就可以和swagger完美结合了。</p>

<p>这样做的好处有三个：</p>

<ol>
<li>注释标准化<br></li>
<li>有了注释之后，以后API代码维护相当方便<br></li>
<li>根据注释自动化生成文档，方便调用的用户查看和测试<br></li>
</ol>

<h2>beego API应用入门</h2>

<p>请大家更新到最新的bee和beego</p>

<pre><code>go get -u github.com/beego/bee
go get -u github.com/astaxie/beego
</code></pre>

<p>然后进入到你的<code>GOPATH/src</code>目录，执行命令<code>bee api bapi</code>,进入目录<code>cd bapi</code>,执行命令<code>bee run -downdoc=true -gendoc=true</code>.请看下面我执行的效果图：</p>

<p><img src="https://raw.githubusercontent.com/beego/beeblog/master/zh-CN/images/bee_api.png" alt="">
</p>

<p>执行完成之后就打开浏览器，输入URL:<a href="javascript:window.open('http://127.0.0.1:8080/swagger/swagger-1/');">http://127.0.0.1:8080/swagger/swagger-1/</a></p>

<blockquote>
<blockquote>
<blockquote>
<p>记住这里必须要用127.0.0.1，不能使用localhost，存在CORS问题，Ajax跨域</p>
</blockquote>
</blockquote>
</blockquote>

<p><img src="https://raw.githubusercontent.com/beego/beeblog/master/zh-CN/images/docs.png" alt="">
</p>

<p>我们的效果和应用都出来了，很酷很炫吧，那这后面到底采用了怎么样的一些技术呢？让我们一步一步来讲解这些细节：</p>

<h2>项目目录</h2>

<p>我们首先来了解一下<code>bee api</code>创建的应用的目录结构：</p>

<pre><code>|-- bapi
|-- conf
|   `-- app.conf
|-- controllers
|   |-- object.go
|   `-- user.go
|-- docs
|   |-- doc.go
|   `-- docs.go
|-- lastupdate.tmp
|-- main.go
|-- models
|   |-- object.go
|   `-- user.go
|-- routers
|   |-- commentsRouter.go
|   `-- router.go
|-- swagger
`-- tests
    `-- default_test.go
</code></pre>

<ul>
<li>main.go 是程序的统一入口文件<br></li>
<li>bapi 是生成的二进制文件<br></li>
<li>conf 配置文件目录，app.conf<br></li>
<li>controllers 控制器目录，主要是逻辑的处理<br></li>
<li>models 是数据处理层的目录<br></li>
<li>docs 是自动化生成文档的目录<br></li>
<li>lastupdate.tmp 是一个注解路由的缓存文件<br></li>
<li>routers是路由目录，主要涉及一些路由规则<br></li>
<li>swagger 是一个html静态资源目录，是通过bee自动下载的，主要就是展示我们看到的界面及测试<br></li>
<li>test 目录是针对应用的测试用例，beego相比其他revel框架的好处之一就是无需启动应用就可以执行test case。<br></li>
</ul>

<h2>入口文件main</h2>

<p>我们第一步先来看一下入口是怎么写的？</p>

<pre><code>package main

import (
    _ &quot;bapi/docs&quot;
    _ &quot;bapi/routers&quot;

    &quot;github.com/astaxie/beego&quot;
)

func main() {
    if beego.RunMode == &quot;dev&quot; {
        beego.DirectoryIndex = true
        beego.StaticDir[&quot;/swagger&quot;] = &quot;swagger&quot;
    }
    beego.Run()
}
</code></pre>

<p>入口文件就是一个普通的beego应用的标准代码，只是这里多了几行代码，把swagger加入了static，因为我们需要把文档服务器集成到beego的API应用中来。然后增加了docs的初始化引入，和router的效果一样。接下里我们先来看看自动化API的路由是怎么设计的</p>

<h2>namespace路由</h2>

<p>自动化路由才有了namespace来进行设计，而且注意两点，第一目前只支持namespace的路由支持自动化文档，第二只支持NSNamespace和NSInclude解析，而且是只能两个层级，先看我们的路由设置：</p>

<pre><code>func init() {
    ns := beego.NewNamespace(&quot;/v1&quot;,
        beego.NSNamespace(&quot;/object&quot;,
            beego.NSInclude(
                &amp;controllers.ObjectController{},
            ),
        ),
        beego.NSNamespace(&quot;/user&quot;,
            beego.NSInclude(
                &amp;controllers.UserController{},
            ),
        ),
    )
    beego.AddNamespace(ns)
}
</code></pre>

<p>我们先来看一下这个代码，首先是使用beego.NewNamespace创建一个ns的变量，这个变量里面其实就是存储了一棵路由树，我们可以把这棵树加到其他任意已经存在的树中去，这也就是namespace的好处，可以在任意的模块中设计自己的namespace，然后把这个namespace加到其他的应用中去，可以增加任意的前缀等。</p>

<p>这里我们分析一下NewNamespace这个函数，这个函数的定义是这样的<code>NewNamespace(prefix string, params ...innnerNamespace) *Namespace</code>，他的第一个参数就是前缀，第二个参数是<code>innnerNamespace</code>多参数，那么我们来看看<code>innnerNamespace</code>的定义是什么：</p>

<pre><code>type innnerNamespace func(*Namespace)
</code></pre>

<p>它是一个函数，也就是只要是符合参数是<code>*Namespace</code>的函数都可以。那么在beego里面定义了如下的方法支持返回这个函数类型：</p>

<ul>
<li>NSCond(cond namespaceCond) innnerNamespace<br></li>
<li>NSBefore(filiterList &hellip;FilterFunc) innnerNamespace<br></li>
<li>NSAfter(filiterList &hellip;FilterFunc) innnerNamespace<br></li>
<li>NSInclude(cList …ControllerInterface) innnerNamespace<br></li>
<li>NSRouter(rootpath string, c ControllerInterface, mappingMethods …string) innnerNamespace<br></li>
<li>NSGet(rootpath string, f FilterFunc) innnerNamespace<br></li>
<li>NSPost(rootpath string, f FilterFunc) innnerNamespace<br></li>
<li>NSDelete(rootpath string, f FilterFunc) innnerNamespace<br></li>
<li>NSPut(rootpath string, f FilterFunc) innnerNamespace<br></li>
<li>NSHead(rootpath string, f FilterFunc) innnerNamespace<br></li>
<li>NSOptions(rootpath string, f FilterFunc) innnerNamespace<br></li>
<li>NSPatch(rootpath string, f FilterFunc) innnerNamespace<br></li>
<li>NSAny(rootpath string, f FilterFunc) innnerNamespace<br></li>
<li>NSHandler(rootpath string, h http.Handler) innnerNamespace<br></li>
<li>NSAutoRouter(c ControllerInterface) innnerNamespace<br></li>
<li>NSAutoPrefix(prefix string, c ControllerInterface) innnerNamespace<br></li>
<li>NSNamespace(prefix string, params …innnerNamespace) innnerNamespace<br></li>
</ul>

<p>因此我们可以在<code>NewNamespace</code>这个函数的第二个参数列表中使用上面的任意函数作为参数调用。</p>

<p>我们看一下路由代码，这是一个层级嵌套的函数，第一个参数是<code>/v1</code>，即为<code>/v1</code>开头的路由树，第二个参数是<code>beego.NSNamespace</code>，第三个参数也是<code>beego.NSNamespace</code>，也就是路由树嵌套了路由树，而我们的<code>beego.NSNamespace</code>里面也是和<code>NewNamespace</code>一样的参数，第一个参数是路由前缀，第二个参数是slice参数。这里我们调用了<code>beego.NSInclude</code>来进行注解路由的引入，这个函数是专门为注解路由设计的，我们可以看到这个设计里面我们没有任何的路由信息，只是设置了前缀，那么这个的路由是在哪里设置的呢？我们接下来分析什么是注解路由。</p>

<h2>注解路由</h2>

<p>可能有些同学不了解什么是注解路由，也就是在Controller类上添加一个注释让框架给自动添加Route，那么我们来看一下<code>ObjectController</code>和<code>UserController</code>中怎么写路由注解的：</p>

<pre><code>// Operations about object
type ObjectController struct {
    beego.Controller
}

// @Title create
// @Description create object
// @Param   body        body    models.Object   true        &quot;The object content&quot;
// @Success 200 {string} models.Object.Id
// @Failure 403 body is empty
// @router / [post]
func (this *ObjectController) Post() {
    var ob models.Object
    json.Unmarshal(this.Ctx.Input.RequestBody, &amp;ob)
    objectid := models.AddOne(ob)
    this.Data[&quot;json&quot;] = map[string]string{&quot;ObjectId&quot;: objectid}
    this.ServeJson()
}
</code></pre>

<p>我们看到我们的每一个函数上面有大段的注释，注解路由其实主要关注最后一行<code>// @router / [post]</code>，这一行的注释就是表示这个函数是注册到路由<code>/</code>，支持方法是<code>post</code>。</p>

<p>和我们平常的时候使用<code>beego.Router(&quot;/&quot;, &amp;ObjectController{},&quot;post:Post&quot;)</code>的效果是一模一样的，只是这一次框架帮你自动注册了这样的路由，框架是如何来自动注册的呢？在应用启动的时候，会判断是否有调用<code>NSInclude</code>，在调用的时候，判断RunMode是否是<code>dev</code>模式，是的话就会判断是否之前有分析过，并且分析对象目录有更新，就使用Go的AST进行源码分析(当然只分析<code>NSInclude</code>调用的<code>controller</code>)，然后生成文件<code>routers/commentsRouter.go</code>，在该文件中会自动注册我们需要的路由信息。这样就完成了整个的注解路由注册。</p>

<p>注解路由是使用<code>// @router</code>开头来申明的，而且必须放在你要注册的函数的上方，和其他注释<code>@Title @Description</code>的顺序无关，你可以放在第一行，也可以最后一行。有两个参数，第一个是需要注册的路由，第二个是支持的方法。</p>

<p>路由可以支持beego支持的任意规则，例如<code>/object/:key</code>这样的参数路由，也可以固定路由<code>/object</code>，也可以是正则路由<code>/cms_:id([0-9]+).html</code></p>

<p>支持的HTTP方法必须使用<code>[]</code>中间是支持的方法列表，多个使用<code>,</code>分割，例如<code>[post,get]</code>。但是目前自动化文档只支持一个方法，也就是你多个的方法的时候无法做到RESTFul到同一个函数，也不鼓励你这样设计的API。如果你API设计的时候支持了多个方法，那么文档生成的时候默认是取第一个作为支持的方法。</p>

<p>上面我们看到我们的方法上面有很多注释，那么接下来就进入我们今天的重点：自动化文档</p>

<h2>自动化文档</h2>

<p>所谓的自动化文档，说白了就是根据我们的注释自动的生成我们可以看得懂的漂亮文档。我们上面也说了写注释不仅仅是方便我们的代码维护，逻辑阐述，同时如果能够自动生成文档，那么对于使用API的用户来说也是很大的帮助。那么如何进行自动化文档生成呢？</p>

<p>我当初看了swagger的展示效果之后，首先研究了他的<a href="javascript:window.open('https://github.com/wordnik/swagger-spec/tree/master/schemas/v1.2');">spec</a>，发现是一些json数据，只要我们的API能够生成swagger认识的json就可以了，因此我的思路就来了，根据注释生成swagger的JSON标准数据输出。swagger提供了一个例子代码：<a href="javascript:window.open('http://petstore.swagger.wordnik.com/');">petstore</a> 我就是根据这个例子的格式一步一步实现了现在的自动化文档。</p>

<p>首先第一步就是API的描述：</p>

<h3>API文档</h3>

<p>我们看到在<code>router.go</code>里面头部有一大段的注释，这些注释就是描述整个项目的一些信息：</p>

<pre><code>// @APIVersion 1.0.0
// @Title beego Test API
// @Description beego has a very cool tools to autogenerate documents for your API
// @Contact astaxie@gmail.com
// @TermsOfServiceUrl http://beego.me/
// @License Apache 2.0
// @LicenseUrl http://www.apache.org/licenses/LICENSE-2.0.html
</code></pre>

<p>这里面主要是几个标志：</p>

<ul>
<li>@APIVersion<br></li>
<li>@Title<br></li>
<li>@Description<br></li>
<li>@Contact<br></li>
<li>@TermsOfServiceUrl<br></li>
<li>@License<br></li>
<li>@LicenseUrl<br></li>
</ul>

<p>这里每一个都不是必须的，你可以写也可以不写，后面就是一个字符串，你可以使用任意喜欢的字符进行描述。我们来看一下生成的：<a href="javascript:window.open('http://127.0.0.1:8080/docs');">http://127.0.0.1:8080/docs</a></p>

<pre><code>{
  &quot;apiVersion&quot;: &quot;1.0.0&quot;,
  &quot;swaggerVersion&quot;: &quot;1.2&quot;,
  &quot;apis&quot;: [
    {
      &quot;path&quot;: &quot;/object&quot;,
      &quot;description&quot;: &quot;Operations about object\n&quot;
    },
    {
      &quot;path&quot;: &quot;/user&quot;,
      &quot;description&quot;: &quot;Operations about Users\n&quot;
    }
  ],
  &quot;info&quot;: {
    &quot;title&quot;: &quot;beego Test API&quot;,
    &quot;description&quot;: &quot;beego has a very cool tools to autogenerate documents for your API&quot;,
    &quot;contact&quot;: &quot;astaxie@gmail.com&quot;,
    &quot;termsOfServiceUrl&quot;: &quot;http://beego.me/&quot;,
    &quot;license&quot;: &quot;Url http://www.apache.org/licenses/LICENSE-2.0.html&quot;
  }
}
</code></pre>

<p>这是首次请求的一些信息，那么apis是怎么来的呢？这个就是根据你的namespace进行源码AST分析获取的，所以目前只支持两层的namespace嵌套，而且必须是两层，第一层是baseurl，第二层就是嵌套的namespace的prefix。也就是上面的path信息，那么里面的description那里获取的呢？请看控制器的注释，</p>

<h3>控制器注释文档</h3>

<p>针对每一个控制我们可以增加注释，用来描述该控制器的作用：</p>

<pre><code>// Operations about object
type ObjectController struct {
    beego.Controller
}
</code></pre>

<p>这个注释就是用来表示我们的每一个控制器API的作用，而控制器的函数里面的注释就是用来表示调用的路由、参数、作用以及返回的信息。</p>

<pre><code>// @Title Get
// @Description find object by objectid
// @Param   objectId        path    string  true        &quot;the objectid you want to get&quot;
// @Success 200 {object} models.Object
// @Failure 403 :objectId is empty
// @router /:objectId [get]
func (this *ObjectController) Get() {
}
</code></pre>

<p>从上面的注释我们可以把我们的注释分为以下类别：</p>

<ul>
<li><p>@Title</p>

<p>接口的标题，用来标示唯一性，唯一，可选</p>

<p>格式：之后跟一个描述字符串</p></li>

<li><p>@Description</p>

<p>接口的作用，用来描述接口的用途，唯一，可选</p>

<p>格式：之后跟一个描述字符串</p></li>

<li><p>@Param</p>

<p>请求的参数，用来描述接受的参数，多个，可选</p>

<p>格式：变量名 传输类型 类型  是否必须  描述</p>

<p>传输类型：</p>

<ul>
<li>query  表示带在url串里面?aa=bb&amp;cc=dd<br></li>
<li>form   表示使用表单递交数据<br></li>
<li>path   表示URL串中得字符，例如/user/{uid} 那么uid就是一个path类型的参数<br></li>
<li>body   表示使用raw body进行数据的传输<br></li>
<li>header 表示通过header进行数据的传输<br></li>
</ul>

<p>类型：</p>

<ul>
<li>string<br></li>
<li>int<br></li>
<li>int64<br></li>
<li>对象，这个地方大家写的时候需要注意，需要是相对于当前项目的路径.对象，例如<code>models.Object</code>表示<code>models</code>目录下的Object对象，这样bee在生成文档的时候会去扫描改对象并显示给用户改对象。<br></li>
</ul>

<p>变量名和描述是一个字符串</p>

<p>是否必须：true 或者false</p></li>

<li><p>@Success</p>

<p>成功返回的code和对象或者信息</p>

<p>格式：code 对象类型 信息或者对象路径</p>

<p>code：表示HTTP的标准status code，200 201等</p>

<p>对象类型：{object}表示对象，其他默认都认为是字符类型，会显示第三个参数给用户，如果是{object}类型，那么就会去扫描改对象，并显示给用户</p>

<p>对象路径和上面Param中得对象类型一样，使用路径.对象的方式来描述</p></li>

<li><p>@Failure</p>

<p>错误返回的信息，</p>

<p>格式： code 信息</p>

<p>code:同上Success</p>

<p>错误信息：字符串描述信息</p></li>

<li><p>@router</p>

<p>上面已经描述过支持两个参数，第一个是路由，第二个表示支持的HTTP方法</p></li>
</ul>

<p>那么我们通过上面的注释会生成怎么样的JSON信息呢？</p>

<pre><code>{
  &quot;path&quot;: &quot;/object/{objectId}&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;operations&quot;: [
    {
      &quot;httpMethod&quot;: &quot;GET&quot;,
      &quot;nickname&quot;: &quot;Get&quot;,
      &quot;type&quot;: &quot;&quot;,
      &quot;summary&quot;: &quot;find object by objectid&quot;,
      &quot;parameters&quot;: [
        {
          &quot;paramType&quot;: &quot;path&quot;,
          &quot;name&quot;: &quot;objectId&quot;,
          &quot;description&quot;: &quot;\&quot;the objectid you want to get\&quot;&quot;,
          &quot;dataType&quot;: &quot;string&quot;,
          &quot;type&quot;: &quot;&quot;,
          &quot;format&quot;: &quot;&quot;,
          &quot;allowMultiple&quot;: false,
          &quot;required&quot;: true,
          &quot;minimum&quot;: 0,
          &quot;maximum&quot;: 0
        }
      ],
      &quot;responseMessages&quot;: [
        {
          &quot;code&quot;: 200,
          &quot;message&quot;: &quot;models.Object&quot;,
          &quot;responseModel&quot;: &quot;Object&quot;
        },
        {
          &quot;code&quot;: 403,
          &quot;message&quot;: &quot;:objectId is empty&quot;,
          &quot;responseModel&quot;: &quot;&quot;
        }
      ]
    }
  ]
}
</code></pre>

<blockquote>
<blockquote>
<blockquote>
<p>上面阐述的这些描述都是可以使用一个或者多个 <code>'\t', '\n', '\v', '\f', '\r', ' ', U+0085 (NEL), U+00A0 (NBSP)</code>进行分割</p>
</blockquote>
</blockquote>
</blockquote>

<h3>对象自定义注释</h3>

<p>我们的对象定义如下：</p>

<pre><code>type Object struct {
    ObjectId   string
    Score      int64
    PlayerName string
}
</code></pre>

<p>通过扫描生成的代码如下：</p>

<pre><code>Object {
ObjectId (string, optional): ,
PlayerName (string, optional): ,
Score (int64, optional):
}
</code></pre>

<p>我们发现字段都是<code>optional</code>的,而且没有任何针对字段的描述，其实我们可以在对象定义里面增加如下的tag：</p>

<pre><code>type Object struct {
    ObjectId   string   `required:&quot;true&quot; description:&quot;object id&quot;`
    Score      int64        `required:&quot;true&quot; description:&quot;players's scores&quot;`
    PlayerName string   `required:&quot;true&quot; description:&quot;plaers name, used in system&quot;`
}
</code></pre>

<p>而且如果你的对象tag里面如果存在json或者thrift描述，那么就会使用改描述作为字段名，即如下的代码：</p>

<pre><code>type Object struct {
    ObjectId   string   `json:&quot;object_id&quot;`
    Score      int64        `json:&quot;player_score&quot;`
    PlayerName string   `json:&quot;player_name&quot;`
}
</code></pre>

<p>就会输出如下的文档信息：</p>

<pre><code>Object {
object_id (string, optional): ,
player_score (string, optional): ,
player_name (int64, optional):
}
</code></pre>

<h2>常见错误及问题</h2>

<ol>
<li>Q:bee没有上面执行的命令？<br></li>
</ol>

<p>A:请更新bee到最新版本，目前bee的版本是1.1.2，beego的版本是1.3.1</p>

<ol>
<li>Q:bee更新的时候出错了？<br></li>
</ol>

<p>A:第一可能是GFW的问题，第二可能是你修改过了源码，删除重新下载，第三可能你升级了Go版本，你需要删除GOPATH/pkg下的所有文件</p>

<ol>
<li>Q:下载swagger很慢？<br></li>
</ol>

<p>A:想办法让他变快,因为我现在放在了github上面</p>

<ol>
<li>Q:文档生成了，但是我没办法测试请求？<br></li>
</ol>

<p>A:你看看你访问的地址是不是和请求的URL是同一个地址，因为swagger是使用Ajax请求数据的，所以跨域的问题，解决CORS的办法就是保持域一致，包括URL和端口。</p>

<ol>
<li>Q:运行的时候发生了未知的错误？<br></li>
</ol>

<p>A:那就来提issue或者给我留言吧，我会尽力帮助你解决你遇到的问题</p>

</body>
</html>

				</div>
			</div>
            <div id="disqus_thread"></div>
<script type="text/javascript">
     
    var disqus_shortname = 'beego'; 

     
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="javascript:window.open('http://disqus.com/?ref_noscript');">comments powered by Disqus.</a></noscript>
<a href="javascript:window.open('http://disqus.com/');" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
		</div>
	</div>
</div>

		    </div>
		    <div class="wrapper-push"></div>
		</div>
		<footer id="footer">
    <div class="container">
        <div class="row footer-wrap">
            <div class="col-md-12 desc">
                <div class="pull-right">
                    <div class="btn-group dropup">
                        <button type="button" class="btn btn-default btn-md dropdown-toggle" data-toggle="dropdown">当前语言:简体中文 <i class="caret"></i></button>
                        <ul class="dropdown-menu">
                            
                                <li><a href="javascript::" data-lang="en-US" class="lang-changed">English</a></li>
                            
                                <li><a href="javascript::" data-lang="ru-RU" class="lang-changed">Russian</a></li>
                            
                        </ul>
                    </div>
                    
                        <a class="btn btn-success" href="donate.html"><i class="icon-dollar"></i> 捐赠我们</a>
                    
                    
                </div>
                
                <p>
                    <a href="about.html"><strong>关于</strong></a>
                    |
                    <a href="team.html"><strong>团队</strong></a>
                    |
                    <a target="_blank" href="javascript:window.open('https://github.com/astaxie/beego');" target="_blank"><strong><i class="icon-github-sign"></i> Github</strong></a>
                    - 23ms.
                </p>

                <p>
                    版权所有 © 2012-2014 Beego 授权许可遵循 <a href="javascript:window.open('http://www.apache.org/licenses/LICENSE-2.0.html');">apache 2.0 licence</a> Logo由 <a target="_blank" href="javascript:window.open('http://mdong.org/');">Tengfei</a> 设计
                </p>

            </div>
        </div>
    </div>
</footer>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-39123845-1', 'beego.me');
  ga('send', 'pageview');

</script>

<script>/* Beego Compress group `lib` begin */</script>
	<script type="text/javascript" src="static/js/jquery.min-1409586500.js"></script>
	<script type="text/javascript" src="static/js/jquery.extend-1409586500.js"></script>
	<script type="text/javascript" src="static/js/bootstrap-1409586500.js"></script>
	<script type="text/javascript" src="static/js/lib.min-1409586500.js"></script>
	<script type="text/javascript" src="static/js/prettify-1409586500.js"></script>
	<script type="text/javascript" src="static/js/jStorage-1409586500.js"></script>
	<script type="text/javascript" src="static/js/jquery.jpanelmenu.min-1409586500.js"></script>
	<script type="text/javascript" src="static/js/jRespond.min-1409586500.js"></script>
	<script type="text/javascript" src="static/js/jquery.clingify.min-1409586500.js"></script>
	<script type="text/javascript" src="static/js/imagesloaded.pkgd.min-1409586500.js"></script>
	<script type="text/javascript" src="static/js/masonry.pkgd.min-1409586500.js"></script>
	<script>/* end */</script>
<script>/* Beego Compress group `app` begin */</script>
	<script type="text/javascript" src="static/js/main-1409586500.js"></script>
	<script>/* end */</script>
	</body>
</html>


