<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<title>Java DSL</title>
<link rel="stylesheet" href="css/spring.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>#header #revnumber{display:none}</style>
</head>
<body class="book toc2 toc-left">
<div id="header">
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#java-dsl">Java DSL</a>
<ul class="sectlevel2">
<li><a href="#java-dsl-basics">DSL Basics</a></li>
<li><a href="#java-dsl-channels">Message Channels</a></li>
<li><a href="#java-dsl-pollers">Pollers</a></li>
<li><a href="#java-dsl-endpoints">DSL and Endpoint Configuration</a></li>
<li><a href="#java-dsl-transformers">Transformers</a></li>
<li><a href="#java-dsl-inbound-adapters">Inbound Channel Adapters</a></li>
<li><a href="#java-dsl-routers">Message Routers</a></li>
<li><a href="#java-dsl-splitters">Splitters</a></li>
<li><a href="#java-dsl-aggregators">Aggregators and Resequencers</a></li>
<li><a href="#java-dsl-handle">Service Activators and the <code>.handle()</code> method</a></li>
<li><a href="#java-dsl-log">Operator log()</a></li>
<li><a href="#java-dsl-intercept">Operator intercept()</a></li>
<li><a href="#java-dsl-wiretap"><code>MessageChannelSpec.wireTap()</code></a></li>
<li><a href="#java-dsl-flows">Working With Message Flows</a></li>
<li><a href="#java-dsl-function-expression"><code>FunctionExpression</code></a></li>
<li><a href="#java-dsl-subflows">Sub-flows support</a></li>
<li><a href="#java-dsl-protocol-adapters">Using Protocol Adapters</a></li>
<li><a href="#java-dsl-flow-adapter"><code>IntegrationFlowAdapter</code></a></li>
<li><a href="#java-dsl-runtime-flows">Dynamic and Runtime Integration Flows</a></li>
<li><a href="#java-dsl-gateway"><code>IntegrationFlow</code> as a Gateway</a></li>
<li><a href="#java-dsl-extensions">DSL Extensions</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="java-dsl"><a class="anchor" href="#java-dsl"></a>Java DSL</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Spring Integration Java configuration and DSL provides a set of convenient builders and a fluent API that lets you configure Spring Integration message flows from Spring <code>@Configuration</code> classes.</p>
</div>
<div class="paragraph">
<p>(See also <a href="./kotlin-dsl.html#kotlin-dsl">Kotlin DSL</a>.)</p>
</div>
<div class="paragraph">
<p>The Java DSL for Spring Integration is essentially a facade for Spring Integration.
The DSL provides a simple way to embed Spring Integration Message Flows into your application by using the fluent <code>Builder</code> pattern together with existing Java configuration from Spring Framework and Spring Integration.
We also use and support lambdas (available with Java 8) to further simplify Java configuration.</p>
</div>
<div class="paragraph">
<p>The <a href="https://github.com/spring-projects/spring-integration-samples/tree/master/dsl/cafe-dsl">cafe</a> offers a good example of using the DSL.</p>
</div>
<div class="paragraph">
<p>The DSL is presented by the <code>IntegrationFlows</code> factory for the <code>IntegrationFlowBuilder</code>.
This produces the <code>IntegrationFlow</code> component, which should be registered as a Spring bean (by using the <code>@Bean</code> annotation).
The builder pattern is used to express arbitrarily complex structures as a hierarchy of methods that can accept lambdas as arguments.</p>
</div>
<div class="paragraph">
<p>The <code>IntegrationFlowBuilder</code> only collects integration components (<code>MessageChannel</code> instances, <code>AbstractEndpoint</code> instances, and so on) in the <code>IntegrationFlow</code> bean for further parsing and registration of concrete beans in the application context by the <code>IntegrationFlowBeanPostProcessor</code>.</p>
</div>
<div class="paragraph">
<p>The Java DSL uses Spring Integration classes directly and bypasses any XML generation and parsing.
However, the DSL offers more than syntactic sugar on top of XML.
One of its most compelling features is the ability to define inline lambdas to implement endpoint logic, eliminating the need for external classes to implement custom logic.
In some sense, Spring Integration&#8217;s support for the Spring Expression Language (SpEL) and inline scripting address this, but lambdas are easier and much more powerful.</p>
</div>
<div class="paragraph">
<p>The following example shows how to use Java Configuration for Spring Integration:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configuration
@EnableIntegration
public class MyConfiguration {

    @Bean
    public AtomicInteger integerSource() {
        return new AtomicInteger();
    }

    @Bean
    public IntegrationFlow myFlow() {
        return IntegrationFlows.from(integerSource::getAndIncrement,
                                         c -&gt; c.poller(Pollers.fixedRate(100)))
                    .channel("inputChannel")
                    .filter((Integer p) -&gt; p &gt; 0)
                    .transform(Object::toString)
                    .channel(MessageChannels.queue())
                    .get();
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The result of the preceding configuration example is that it creates, after <code>ApplicationContext</code> start up, Spring Integration endpoints and message channels.
Java configuration can be used both to replace and augment XML configuration.
You need not replace all of your existing XML configuration to use Java configuration.</p>
</div>
<div class="sect2">
<h3 id="java-dsl-basics"><a class="anchor" href="#java-dsl-basics"></a>DSL Basics</h3>
<div class="paragraph">
<p>The <code>org.springframework.integration.dsl</code> package contains the <code>IntegrationFlowBuilder</code> API mentioned earlier and a number of <code>IntegrationComponentSpec</code> implementations, which are also builders and provide the fluent API to configure concrete endpoints.
The <code>IntegrationFlowBuilder</code> infrastructure provides common <a href="https://www.enterpriseintegrationpatterns.com/">enterprise integration patterns</a> (EIP) for message-based applications, such as channels, endpoints, pollers, and channel interceptors.</p>
</div>
<div class="paragraph">
<p>Endpoints are expressed as verbs in the DSL to improve readability.
The following list includes the common DSL method names and the associated EIP endpoint:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>transform &#8594; <code>Transformer</code></p>
</li>
<li>
<p>filter &#8594; <code>Filter</code></p>
</li>
<li>
<p>handle &#8594; <code>ServiceActivator</code></p>
</li>
<li>
<p>split &#8594; <code>Splitter</code></p>
</li>
<li>
<p>aggregate &#8594; <code>Aggregator</code></p>
</li>
<li>
<p>route &#8594; <code>Router</code></p>
</li>
<li>
<p>bridge &#8594; <code>Bridge</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Conceptually, integration processes are constructed by composing these endpoints into one or more message flows.
Note that EIP does not formally define the term 'message flow', but it is useful to think of it as a unit of work that uses well known messaging patterns.
The DSL provides an <code>IntegrationFlow</code> component to define a composition of channels and endpoints between them, but now <code>IntegrationFlow</code> plays only the configuration role to populate real beans in the application context and is not used at runtime.
The following example uses the <code>IntegrationFlows</code> factory to define an <code>IntegrationFlow</code> bean by using EIP-methods from <code>IntegrationFlowBuilder</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Bean
public IntegrationFlow integerFlow() {
    return IntegrationFlows.from("input")
            .&lt;String, Integer&gt;transform(Integer::parseInt)
            .get();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>transform</code> method accepts a lambda as an endpoint argument to operate on the message payload.
The real argument of this method is <code>GenericTransformer&lt;S, T&gt;</code>.
Consequently, any of the provided transformers (<code>ObjectToJsonTransformer</code>, <code>FileToStringTransformer</code>, and other) can be used here.</p>
</div>
<div class="paragraph">
<p>Under the covers, <code>IntegrationFlowBuilder</code> recognizes the <code>MessageHandler</code> and the endpoint for it, with <code>MessageTransformingHandler</code> and <code>ConsumerEndpointFactoryBean</code>, respectively.
Consider another example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Bean
public IntegrationFlow myFlow() {
    return IntegrationFlows.from("input")
                .filter("World"::equals)
                .transform("Hello "::concat)
                .handle(System.out::println)
                .get();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding example composes a sequence of <code>Filter &#8594; Transformer &#8594; Service Activator</code>.
The flow is "'one way'".
That is, it does not provide a reply message but only prints the payload to STDOUT.
The endpoints are automatically wired together by using direct channels.</p>
</div>
<div id="java-dsl-class-cast" class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="title">Lambdas And <code>Message&lt;?&gt;</code> Arguments</div>
<div class="paragraph">
<p>When using lambdas in EIP methods, the "input" argument is generally the message payload.
If you wish to access the entire message, use one of the overloaded methods that take a <code>Class&lt;?&gt;</code> as the first parameter.
For example, this won&#8217;t work:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">.&lt;Message&lt;?&gt;, Foo&gt;transform(m -&gt; newFooFromMessage(m))</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will fail at runtime with a <code>ClassCastException</code> because the lambda doesn&#8217;t retain the argument type and the framework will attempt to cast the payload to a <code>Message&lt;?&gt;</code>.</p>
</div>
<div class="paragraph">
<p>Instead, use:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">.(Message.class, m -&gt; newFooFromMessage(m))</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div id="bean-definitions-override" class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="title">Bean Definitions override</div>
<div class="paragraph">
<p>The Java DSL can register beans for the object defined in-line in the flow definition, as well as can reuse existing, injected beans.
In case of the same bean name defined for in-line object and existing bean definition, a <code>BeanDefinitionOverrideException</code> is thrown indicating that such a configuration is wrong.
However when you deal with <code>prototype</code> beans, there is no way to detect from the integration flow processor an existing bean definition because every time we call a <code>prototype</code> bean from the <code>BeanFactory</code> we get a new instance.
This way a provided instance is used in the <code>IntegrationFlow</code> as is without any bean registration and any possible check against existing <code>prototype</code> bean definition.
However <code>BeanFactory.initializeBean()</code> is called for this object if it has an explicit <code>id</code> and bean definition for this name is in <code>prototype</code> scope.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="java-dsl-channels"><a class="anchor" href="#java-dsl-channels"></a>Message Channels</h3>
<div class="paragraph">
<p>In addition to the <code>IntegrationFlowBuilder</code> with EIP methods, the Java DSL provides a fluent API to configure <code>MessageChannel</code> instances.
For this purpose the <code>MessageChannels</code> builder factory is provided.
The following example shows how to use it:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Bean
public MessageChannel priorityChannel() {
    return MessageChannels.priority(this.mongoDbChannelMessageStore, "priorityGroup")
                        .interceptor(wireTap())
                        .get();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The same <code>MessageChannels</code> builder factory can be used in the <code>channel()</code> EIP method from <code>IntegrationFlowBuilder</code> to wire endpoints, similar to wiring an <code>input-channel</code>/<code>output-channel</code> pair in the XML configuration.
By default, endpoints are wired with <code>DirectChannel</code> instances where the bean name is based on the following pattern: <code>[IntegrationFlow.beanName].channel#[channelNameIndex]</code>.
This rule is also applied for unnamed channels produced by inline <code>MessageChannels</code> builder factory usage.
However all <code>MessageChannels</code> methods have a variant that is aware of the <code>channelId</code> that you can use to set the bean names for <code>MessageChannel</code> instances.
The <code>MessageChannel</code> references and <code>beanName</code> can be used as bean-method invocations.
The following example shows the possible ways to use the <code>channel()</code> EIP method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Bean
public MessageChannel queueChannel() {
    return MessageChannels.queue().get();
}

@Bean
public MessageChannel publishSubscribe() {
    return MessageChannels.publishSubscribe().get();
}

@Bean
public IntegrationFlow channelFlow() {
    return IntegrationFlows.from("input")
                .fixedSubscriberChannel()
                .channel("queueChannel")
                .channel(publishSubscribe())
                .channel(MessageChannels.executor("executorChannel", this.taskExecutor))
                .channel("output")
                .get();
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>from("input")</code> means "'find and use the <code>MessageChannel</code> with the "input" id, or create one'".</p>
</li>
<li>
<p><code>fixedSubscriberChannel()</code> produces an instance of <code>FixedSubscriberChannel</code> and registers it with a name of <code>channelFlow.channel#0</code>.</p>
</li>
<li>
<p><code>channel("queueChannel")</code> works the same way but uses an existing <code>queueChannel</code> bean.</p>
</li>
<li>
<p><code>channel(publishSubscribe())</code> is the bean-method reference.</p>
</li>
<li>
<p><code>channel(MessageChannels.executor("executorChannel", this.taskExecutor))</code> is the <code>IntegrationFlowBuilder</code> that exposes <code>IntegrationComponentSpec</code> to the <code>ExecutorChannel</code> and registers it as <code>executorChannel</code>.</p>
</li>
<li>
<p><code>channel("output")</code> registers the <code>DirectChannel</code> bean with <code>output</code> as its name, as long as no beans with this name already exist.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Note: The preceding <code>IntegrationFlow</code> definition is valid, and all of its channels are applied to endpoints with <code>BridgeHandler</code> instances.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Be careful to use the same inline channel definition through <code>MessageChannels</code> factory from different <code>IntegrationFlow</code> instances.
Even if the DSL parser registers non-existent objects as beans, it cannot determine the same object (<code>MessageChannel</code>) from different <code>IntegrationFlow</code> containers.
The following example is wrong:
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Bean
public IntegrationFlow startFlow() {
    return IntegrationFlows.from("input")
                .transform(...)
                .channel(MessageChannels.queue("queueChannel"))
                .get();
}

@Bean
public IntegrationFlow endFlow() {
    return IntegrationFlows.from(MessageChannels.queue("queueChannel"))
                .handle(...)
                .get();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The result of that bad example is the following exception:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">Caused by: java.lang.IllegalStateException:
Could not register object [queueChannel] under bean name 'queueChannel':
     there is already object [queueChannel] bound
	    at o.s.b.f.s.DefaultSingletonBeanRegistry.registerSingleton(DefaultSingletonBeanRegistry.java:129)</code></pre>
</div>
</div>
<div class="paragraph">
<p>To make it work, you need to declare <code>@Bean</code> for that channel and use its bean method from different <code>IntegrationFlow</code> instances.</p>
</div>
</div>
<div class="sect2">
<h3 id="java-dsl-pollers"><a class="anchor" href="#java-dsl-pollers"></a>Pollers</h3>
<div class="paragraph">
<p>Spring Integration also provides a fluent API that lets you configure <code>PollerMetadata</code> for <code>AbstractPollingEndpoint</code> implementations.
You can use the <code>Pollers</code> builder factory to configure common bean definitions or those created from <code>IntegrationFlowBuilder</code> EIP methods, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Bean(name = PollerMetadata.DEFAULT_POLLER)
public PollerSpec poller() {
    return Pollers.fixedRate(500)
        .errorChannel("myErrors");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>See <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/dsl/Pollers.html"><code>Pollers</code></a> and <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/dsl/PollerSpec.html"><code>PollerSpec</code></a> in the Javadoc for more information.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
If you use the DSL to construct a <code>PollerSpec</code> as a <code>@Bean</code>, do not call the <code>get()</code> method in the bean definition.
The <code>PollerSpec</code> is a <code>FactoryBean</code> that generates the <code>PollerMetadata</code> object from the specification and initializes all of its properties.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="java-dsl-endpoints"><a class="anchor" href="#java-dsl-endpoints"></a>DSL and Endpoint Configuration</h3>
<div class="paragraph">
<p>All <code>IntegrationFlowBuilder</code> EIP methods have a variant that applies the lambda parameter to provide options for <code>AbstractEndpoint</code> instances: <code>SmartLifecycle</code>, <code>PollerMetadata</code>, <code>request-handler-advice-chain</code>, and others.
Each of them has generic arguments, so it lets you configure an endpoint and even its <code>MessageHandler</code> in the context, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Bean
public IntegrationFlow flow2() {
    return IntegrationFlows.from(this.inputChannel)
                .transform(new PayloadSerializingTransformer(),
                       c -&gt; c.autoStartup(false).id("payloadSerializingTransformer"))
                .transform((Integer p) -&gt; p * 2, c -&gt; c.advice(this.expressionAdvice()))
                .get();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In addition, the <code>EndpointSpec</code> provides an <code>id()</code> method to let you register an endpoint bean with a given bean name, rather than a generated one.</p>
</div>
<div class="paragraph">
<p>If the <code>MessageHandler</code> is referenced as a bean, then any existing <code>adviceChain</code> configuration will be overridden if the <code>.advice()</code> method is present in the DSL definition:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Bean
public TcpOutboundGateway tcpOut() {
    TcpOutboundGateway gateway = new TcpOutboundGateway();
    gateway.setConnectionFactory(cf());
    gateway.setAdviceChain(Collections.singletonList(fooAdvice()));
    return gateway;
}

@Bean
public IntegrationFlow clientTcpFlow() {
    return f -&gt; f
        .handle(tcpOut(), e -&gt; e.advice(testAdvice()))
        .transform(Transformers.objectToString());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>That is they are not merged, only the <code>testAdvice()</code> bean is used in this case.</p>
</div>
</div>
<div class="sect2">
<h3 id="java-dsl-transformers"><a class="anchor" href="#java-dsl-transformers"></a>Transformers</h3>
<div class="paragraph">
<p>The DSL API provides a convenient, fluent <code>Transformers</code> factory to be used as inline target object definition within the <code>.transform()</code> EIP method.
The following example shows how to use it:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Bean
public IntegrationFlow transformFlow() {
    return IntegrationFlows.from("input")
            .transform(Transformers.fromJson(MyPojo.class))
            .transform(Transformers.serializer())
            .get();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>It avoids inconvenient coding using setters and makes the flow definition more straightforward.
Note that you can use <code>Transformers</code> to declare target <code>Transformer</code> instances as <code>@Bean</code> instances and, again, use them from <code>IntegrationFlow</code> definition as bean methods.
Nevertheless, the DSL parser takes care of bean declarations for inline objects, if they are not yet defined as beans.</p>
</div>
<div class="paragraph">
<p>See <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/dsl/Transformers.html">Transformers</a> in the Javadoc for more information and supported factory methods.</p>
</div>
<div class="paragraph">
<p>Also see <a href="#java-dsl-class-cast">Lambdas And <code>Message&lt;?&gt;</code> Arguments</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="java-dsl-inbound-adapters"><a class="anchor" href="#java-dsl-inbound-adapters"></a>Inbound Channel Adapters</h3>
<div class="paragraph">
<p>Typically, message flows start from an inbound channel adapter (such as <code>&lt;int-jdbc:inbound-channel-adapter&gt;</code>).
The adapter is configured with <code>&lt;poller&gt;</code>, and it asks a <code>MessageSource&lt;?&gt;</code> to periodically produce messages.
Java DSL allows for starting <code>IntegrationFlow</code> from a <code>MessageSource&lt;?&gt;</code>, too.
For this purpose, the <code>IntegrationFlows</code> builder factory provides an overloaded <code>IntegrationFlows.from(MessageSource&lt;?&gt; messageSource)</code> method.
You can configure the <code>MessageSource&lt;?&gt;</code> as a bean and provide it as an argument for that method.
The second parameter of <code>IntegrationFlows.from()</code> is a <code>Consumer&lt;SourcePollingChannelAdapterSpec&gt;</code> lambda that lets you provide options (such as <code>PollerMetadata</code> or <code>SmartLifecycle</code>) for the <code>SourcePollingChannelAdapter</code>.
The following example shows how to use the fluent API and a lambda to create an <code>IntegrationFlow</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Bean
public MessageSource&lt;Object&gt; jdbcMessageSource() {
    return new JdbcPollingChannelAdapter(this.dataSource, "SELECT * FROM something");
}

@Bean
public IntegrationFlow pollingFlow() {
    return IntegrationFlows.from(jdbcMessageSource(),
                c -&gt; c.poller(Pollers.fixedRate(100).maxMessagesPerPoll(1)))
            .transform(Transformers.toJson())
            .channel("furtherProcessChannel")
            .get();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>For those cases that have no requirements to build <code>Message</code> objects directly, you can use the <code>IntegrationFlows.from()</code> variant that is based on the <code>java.util.function.Supplier</code> .
The result of the <code>Supplier.get()</code> is automatically wrapped in a <code>Message</code> (if it is not already a <code>Message</code>).</p>
</div>
</div>
<div class="sect2">
<h3 id="java-dsl-routers"><a class="anchor" href="#java-dsl-routers"></a>Message Routers</h3>
<div class="paragraph">
<p>Spring Integration natively provides specialized router types, including:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>HeaderValueRouter</code></p>
</li>
<li>
<p><code>PayloadTypeRouter</code></p>
</li>
<li>
<p><code>ExceptionTypeRouter</code></p>
</li>
<li>
<p><code>RecipientListRouter</code></p>
</li>
<li>
<p><code>XPathRouter</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>As with many other DSL <code>IntegrationFlowBuilder</code> EIP methods, the <code>route()</code> method can apply any <code>AbstractMessageRouter</code> implementation or, for convenience, a <code>String</code> as a SpEL expression or a <code>ref</code>-<code>method</code> pair.
In addition, you can configure <code>route()</code> with a lambda and use a lambda for a <code>Consumer&lt;RouterSpec&lt;MethodInvokingRouter&gt;&gt;</code>.
The fluent API also provides <code>AbstractMappingMessageRouter</code> options such as <code>channelMapping(String key, String channelName)</code> pairs, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Bean
public IntegrationFlow routeFlowByLambda() {
    return IntegrationFlows.from("routerInput")
            .&lt;Integer, Boolean&gt;route(p -&gt; p % 2 == 0,
                    m -&gt; m.suffix("Channel")
                            .channelMapping(true, "even")
                            .channelMapping(false, "odd")
            )
            .get();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows a simple expression-based router:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Bean
public IntegrationFlow routeFlowByExpression() {
    return IntegrationFlows.from("routerInput")
            .route("headers['destChannel']")
            .get();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>routeToRecipients()</code> method takes a <code>Consumer&lt;RecipientListRouterSpec&gt;</code>, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Bean
public IntegrationFlow recipientListFlow() {
    return IntegrationFlows.from("recipientListInput")
            .&lt;String, String&gt;transform(p -&gt; p.replaceFirst("Payload", ""))
            .routeToRecipients(r -&gt; r
                    .recipient("thing1-channel", "'thing1' == payload")
                    .recipientMessageSelector("thing2-channel", m -&gt;
                            m.getHeaders().containsKey("recipient")
                                    &amp;&amp; (boolean) m.getHeaders().get("recipient"))
                    .recipientFlow("'thing1' == payload or 'thing2' == payload or 'thing3' == payload",
                            f -&gt; f.&lt;String, String&gt;transform(String::toUpperCase)
                                    .channel(c -&gt; c.queue("recipientListSubFlow1Result")))
                    .recipientFlow((String p) -&gt; p.startsWith("thing3"),
                            f -&gt; f.transform("Hello "::concat)
                                    .channel(c -&gt; c.queue("recipientListSubFlow2Result")))
                    .recipientFlow(new FunctionExpression&lt;Message&lt;?&gt;&gt;(m -&gt;
                                    "thing3".equals(m.getPayload())),
                            f -&gt; f.channel(c -&gt; c.queue("recipientListSubFlow3Result")))
                    .defaultOutputToParentFlow())
            .get();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>.defaultOutputToParentFlow()</code> of the <code>.routeToRecipients()</code> definition lets you set the router&#8217;s <code>defaultOutput</code> as a gateway to continue a process for the unmatched messages in the main flow.</p>
</div>
<div class="paragraph">
<p>Also see <a href="#java-dsl-class-cast">Lambdas And <code>Message&lt;?&gt;</code> Arguments</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="java-dsl-splitters"><a class="anchor" href="#java-dsl-splitters"></a>Splitters</h3>
<div class="paragraph">
<p>To create a splitter, use the <code>split()</code> EIP method.
By default, if the payload is an <code>Iterable</code>, an <code>Iterator</code>, an <code>Array</code>, a <code>Stream</code>, or a reactive <code>Publisher</code>, the <code>split()</code> method outputs each item as an individual message.
It accepts a lambda, a SpEL expression, or any <code>AbstractMessageSplitter</code> implementation.
Alternatively, you can use it without parameters to provide the <code>DefaultMessageSplitter</code>.
The following example shows how to use the <code>split()</code> method by providing a lambda:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Bean
public IntegrationFlow splitFlow() {
    return IntegrationFlows.from("splitInput")
              .split(s -&gt; s.applySequence(false).delimiters(","))
              .channel(MessageChannels.executor(taskExecutor()))
              .get();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding example creates a splitter that splits a message containing a comma-delimited <code>String</code>.</p>
</div>
<div class="paragraph">
<p>Also see <a href="#java-dsl-class-cast">Lambdas And <code>Message&lt;?&gt;</code> Arguments</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="java-dsl-aggregators"><a class="anchor" href="#java-dsl-aggregators"></a>Aggregators and Resequencers</h3>
<div class="paragraph">
<p>An <code>Aggregator</code> is conceptually the opposite of a <code>Splitter</code>.
It aggregates a sequence of individual messages into a single message and is necessarily more complex.
By default, an aggregator returns a message that contains a collection of payloads from incoming messages.
The same rules are applied for the <code>Resequencer</code>.
The following example shows a canonical example of the splitter-aggregator pattern:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Bean
public IntegrationFlow splitAggregateFlow() {
    return IntegrationFlows.from("splitAggregateInput")
            .split()
            .channel(MessageChannels.executor(this.taskExecutor()))
            .resequence()
            .aggregate()
            .get();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>split()</code> method splits the list into individual messages and sends them to the <code>ExecutorChannel</code>.
The <code>resequence()</code> method reorders messages by sequence details found in the message headers.
The <code>aggregate()</code> method collects those messages.</p>
</div>
<div class="paragraph">
<p>However, you can change the default behavior by specifying a release strategy and correlation strategy, among other things.
Consider the following example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">.aggregate(a -&gt;
        a.correlationStrategy(m -&gt; m.getHeaders().get("myCorrelationKey"))
            .releaseStrategy(g -&gt; g.size() &gt; 10)
            .messageStore(messageStore()))</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding example correlates messages that have <code>myCorrelationKey</code> headers and releases the messages once at least ten have been accumulated.</p>
</div>
<div class="paragraph">
<p>Similar lambda configurations are provided for the <code>resequence()</code> EIP method.</p>
</div>
</div>
<div class="sect2">
<h3 id="java-dsl-handle"><a class="anchor" href="#java-dsl-handle"></a>Service Activators and the <code>.handle()</code> method</h3>
<div class="paragraph">
<p>The <code>.handle()</code> EIP method&#8217;s goal is to invoke any <code>MessageHandler</code> implementation or any method on some POJO.
Another option is to define an &#8220;activity&#8221; by using lambda expressions.
Consequently, we introduced a generic <code>GenericHandler&lt;P&gt;</code> functional interface.
Its <code>handle</code> method requires two arguments: <code>P payload</code> and <code>MessageHeaders headers</code> (starting with version 5.1).
Having that, we can define a flow as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Bean
public IntegrationFlow myFlow() {
    return IntegrationFlows.from("flow3Input")
        .&lt;Integer&gt;handle((p, h) -&gt; p * 2)
        .get();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding example doubles any integer it receives.</p>
</div>
<div class="paragraph">
<p>However, one main goal of Spring Integration is <code>loose coupling</code>, through runtime type conversion from message payload to the target arguments of the message handler.
Since Java does not support generic type resolution for lambda classes, we introduced a workaround with an additional <code>payloadType</code> argument for the most EIP methods and <code>LambdaMessageProcessor</code>.
Doing so delegates the hard conversion work to Spring&#8217;s <code>ConversionService</code>, which uses the provided <code>type</code> and the requested message to target method arguments.
The following example shows what the resulting <code>IntegrationFlow</code> might look like:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Bean
public IntegrationFlow integerFlow() {
    return IntegrationFlows.from("input")
            .&lt;byte[], String&gt;transform(p - &gt; new String(p, "UTF-8"))
            .handle(Integer.class, (p, h) -&gt; p * 2)
            .get();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>We also can register some <code>BytesToIntegerConverter</code> within <code>ConversionService</code> to get rid of that additional <code>.transform()</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Bean
@IntegrationConverter
public BytesToIntegerConverter bytesToIntegerConverter() {
   return new BytesToIntegerConverter();
}

@Bean
public IntegrationFlow integerFlow() {
    return IntegrationFlows.from("input")
             .handle(Integer.class, (p, h) -&gt; p * 2)
            .get();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Also see <a href="#java-dsl-class-cast">Lambdas And <code>Message&lt;?&gt;</code> Arguments</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="java-dsl-log"><a class="anchor" href="#java-dsl-log"></a>Operator log()</h3>
<div class="paragraph">
<p>For convenience, to log the message journey through the Spring Integration flow (<code>&lt;logging-channel-adapter&gt;</code>), a <code>log()</code> operator is presented.
Internally, it is represented by the <code>WireTap</code> <code>ChannelInterceptor</code> with a <code>LoggingHandler</code> as its subscriber.
It is responsible for logging the incoming message into the next endpoint or the current channel.
The following example shows how to use <code>LoggingHandler</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">.filter(...)
.log(LoggingHandler.Level.ERROR, "test.category", m -&gt; m.getHeaders().getId())
.route(...)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, an <code>id</code> header is logged at the <code>ERROR</code> level onto <code>test.category</code> only for messages that passed the filter and before routing.</p>
</div>
<div class="paragraph">
<p>When this operator is used at the end of a flow, it is a one-way handler and the flow ends.
To make it as a reply-producing flow, you can either use a simple <code>bridge()</code> after the <code>log()</code> or, starting with version 5.1, you can use a <code>logAndReply()</code> operator instead.
<code>logAndReply</code> can only be used at the end of a flow.</p>
</div>
</div>
<div class="sect2">
<h3 id="java-dsl-intercept"><a class="anchor" href="#java-dsl-intercept"></a>Operator intercept()</h3>
<div class="paragraph">
<p>Starting with version 5.3, the <code>intercept()</code> operator allows to register one or more <code>ChannelInterceptor</code> instances at the current <code>MessageChannel</code> in the flow.
This is an alternative to creating an explicit <code>MessageChannel</code> via the <code>MessageChannels</code> API.
The following example uses a <code>MessageSelectingInterceptor</code> to reject certain messages with an exception:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">.transform(...)
.intercept(new MessageSelectingInterceptor(m -&gt; m.getPayload().isValid()))
.handle(...)</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="java-dsl-wiretap"><a class="anchor" href="#java-dsl-wiretap"></a><code>MessageChannelSpec.wireTap()</code></h3>
<div class="paragraph">
<p>Spring Integration includes a <code>.wireTap()</code> fluent API <code>MessageChannelSpec</code> builders.
The following example shows how to use the <code>wireTap</code> method to log input:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Bean
public QueueChannelSpec myChannel() {
    return MessageChannels.queue()
            .wireTap("loggingFlow.input");
}

@Bean
public IntegrationFlow loggingFlow() {
    return f -&gt; f.log();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If the <code>MessageChannel</code> is an instance of <code>InterceptableChannel</code>, the <code>log()</code>, <code>wireTap()</code> or <code>intercept()</code> operators are applied to the current <code>MessageChannel</code>.
Otherwise, an intermediate <code>DirectChannel</code> is injected into the flow for the currently configured endpoint.
In the following example, the <code>WireTap</code> interceptor is added to <code>myChannel</code> directly, because <code>DirectChannel</code> implements <code>InterceptableChannel</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Bean
MessageChannel myChannel() {
    return new DirectChannel();
}

...
    .channel(myChannel())
    .log()
}</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When the current <code>MessageChannel</code> does not implement <code>InterceptableChannel</code>, an implicit <code>DirectChannel</code> and <code>BridgeHandler</code> are injected into the <code>IntegrationFlow</code>, and the <code>WireTap</code> is added to this new <code>DirectChannel</code>.
The following example does not have any channel declaration:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">.handle(...)
.log()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding example (and any time no channel has been declared), an implicit <code>DirectChannel</code> is injected in the current position of the <code>IntegrationFlow</code> and used as an output channel for the currently configured <code>ServiceActivatingHandler</code> (from the <code>.handle()</code>, <a href="#java-dsl-handle">described earlier</a>).</p>
</div>
</div>
<div class="sect2">
<h3 id="java-dsl-flows"><a class="anchor" href="#java-dsl-flows"></a>Working With Message Flows</h3>
<div class="paragraph">
<p><code>IntegrationFlowBuilder</code> provides a top-level API to produce integration components wired to message flows.
When your integration may be accomplished with a single flow (which is often the case), this is convenient.
Alternately <code>IntegrationFlow</code> instances can be joined via <code>MessageChannel</code> instances.</p>
</div>
<div class="paragraph">
<p>By default, <code>MessageFlow</code> behaves as a &#8220;chain&#8221; in Spring Integration parlance.
That is, the endpoints are automatically and implicitly wired by <code>DirectChannel</code> instances.
The message flow is not actually constructed as a chain, which offers much more flexibility.
For example, you may send a message to any component within the flow, if you know its <code>inputChannel</code> name (that is, if you explicitly define it).
You may also reference externally defined channels within a flow to allow the use of channel adapters (to enable remote transport protocols, file I/O, and so on), instead of direct channels.
As such, the DSL does not support the Spring Integration <code>chain</code> element, because it does not add much value in this case.</p>
</div>
<div class="paragraph">
<p>Since the Spring Integration Java DSL produces the same bean definition model as any other configuration options and is based on the existing Spring Framework <code>@Configuration</code> infrastructure, it can be used together with XML definitions and wired with Spring Integration messaging annotation configuration.</p>
</div>
<div class="paragraph">
<p>You can also define direct <code>IntegrationFlow</code> instances by using a lambda.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Bean
public IntegrationFlow lambdaFlow() {
    return f -&gt; f.filter("World"::equals)
                   .transform("Hello "::concat)
                   .handle(System.out::println);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The result of this definition is the same set of integration components that are wired with an implicit direct channel.
The only limitation here is that this flow is started with a named direct channel - <code>lambdaFlow.input</code>.
Also, a Lambda flow cannot start from <code>MessageSource</code> or <code>MessageProducer</code>.</p>
</div>
<div class="paragraph">
<p>Starting with version 5.1, this kind of <code>IntegrationFlow</code> is wrapped to the proxy to expose lifecycle control and provide access to the <code>inputChannel</code> of the internally associated <code>StandardIntegrationFlow</code>.</p>
</div>
<div class="paragraph">
<p>Starting with version 5.0.6, the generated bean names for the components in an <code>IntegrationFlow</code> include the flow bean followed by a dot (<code>.</code>) as a prefix.
For example, the <code>ConsumerEndpointFactoryBean</code> for the <code>.transform("Hello "::concat)</code> in the preceding sample results in a bean name of <code>lambdaFlow.o.s.i.config.ConsumerEndpointFactoryBean#0</code>.
(The <code>o.s.i</code> is a shortened from <code>org.springframework.integration</code> to fit on the page.)
The <code>Transformer</code> implementation bean for that endpoint has a bean name of <code>lambdaFlow.transformer#0</code> (starting with version 5.1), where instead of a fully qualified name of the <code>MethodInvokingTransformer</code> class, its component type is used.
The same pattern is applied for all the <code>NamedComponent</code> s when the bean name has to be generated within the flow.
These generated bean names are prepended with the flow ID for purposes such as parsing logs or grouping components together in some analysis tool, as well as to avoid a race condition when we concurrently register integration flows at runtime.
See <a href="#java-dsl-runtime-flows">Dynamic and Runtime Integration Flows</a> for more information.</p>
</div>
</div>
<div class="sect2">
<h3 id="java-dsl-function-expression"><a class="anchor" href="#java-dsl-function-expression"></a><code>FunctionExpression</code></h3>
<div class="paragraph">
<p>We introduced the <code>FunctionExpression</code> class (an implementation of SpEL&#8217;s <code>Expression</code> interface) to let us use lambdas and <code>generics</code>.
The <code>Function&lt;T, R&gt;</code> option is provided for the DSL components, along with an <code>expression</code> option, when there is the implicit <code>Strategy</code> variant from Core Spring Integration.
The following example shows how to use a function expression:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">.enrich(e -&gt; e.requestChannel("enrichChannel")
            .requestPayload(Message::getPayload)
            .propertyFunction("date", m -&gt; new Date()))</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>FunctionExpression</code> also supports runtime type conversion, as is done in <code>SpelExpression</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="java-dsl-subflows"><a class="anchor" href="#java-dsl-subflows"></a>Sub-flows support</h3>
<div class="paragraph">
<p>Some of <code>if&#8230;&#8203;else</code> and <code>publish-subscribe</code> components provide the ability to specify their logic or mapping by using sub-flows.
The simplest sample is <code>.publishSubscribeChannel()</code>, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Bean
public IntegrationFlow subscribersFlow() {
    return flow -&gt; flow
            .publishSubscribeChannel(Executors.newCachedThreadPool(), s -&gt; s
                    .subscribe(f -&gt; f
                            .&lt;Integer&gt;handle((p, h) -&gt; p / 2)
                            .channel(c -&gt; c.queue("subscriber1Results")))
                    .subscribe(f -&gt; f
                            .&lt;Integer&gt;handle((p, h) -&gt; p * 2)
                            .channel(c -&gt; c.queue("subscriber2Results"))))
            .&lt;Integer&gt;handle((p, h) -&gt; p * 3)
            .channel(c -&gt; c.queue("subscriber3Results"));
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can achieve the same result with separate <code>IntegrationFlow</code> <code>@Bean</code> definitions, but we hope you find the sub-flow style of logic composition useful.
We find that it results in shorter (and so more readable) code.</p>
</div>
<div class="paragraph">
<p>Starting with version 5.3, a <code>BroadcastCapableChannel</code>-based <code>publishSubscribeChannel()</code> implementation is provided to configure sub-flow subscribers on broker-backed message channels.
For example we now can configure several subscribers as sub-flows on the <code>Jms.publishSubscribeChannel()</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Bean
public BroadcastCapableChannel jmsPublishSubscribeChannel() {
    return Jms.publishSubscribeChannel(jmsConnectionFactory())
                .destination("pubsub")
                .get();
}

@Bean
public IntegrationFlow pubSubFlow() {
    return f -&gt; f
            .publishSubscribeChannel(jmsPublishSubscribeChannel(),
                    pubsub -&gt; pubsub
                            .subscribe(subFlow -&gt; subFlow
                                .channel(c -&gt; c.queue("jmsPubSubBridgeChannel1")))
                            .subscribe(subFlow -&gt; subFlow
                                .channel(c -&gt; c.queue("jmsPubSubBridgeChannel2"))));
}

@Bean
public BroadcastCapableChannel jmsPublishSubscribeChannel(ConnectionFactory jmsConnectionFactory) {
    return (BroadcastCapableChannel) Jms.publishSubscribeChannel(jmsConnectionFactory)
            .destination("pubsub")
            .get();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>A similar <code>publish-subscribe</code> sub-flow composition provides the <code>.routeToRecipients()</code> method.</p>
</div>
<div class="paragraph">
<p>Another example is using <code>.discardFlow()</code> instead of <code>.discardChannel()</code> on the <code>.filter()</code> method.</p>
</div>
<div class="paragraph">
<p>The <code>.route()</code> deserves special attention.
Consider the following example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Bean
public IntegrationFlow routeFlow() {
    return f -&gt; f
            .&lt;Integer, Boolean&gt;route(p -&gt; p % 2 == 0,
                    m -&gt; m.channelMapping("true", "evenChannel")
                            .subFlowMapping("false", sf -&gt;
                                    sf.&lt;Integer&gt;handle((p, h) -&gt; p * 3)))
            .transform(Object::toString)
            .channel(c -&gt; c.queue("oddChannel"));
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>.channelMapping()</code> continues to work as it does in regular <code>Router</code> mapping, but the <code>.subFlowMapping()</code> tied that sub-flow to the main flow.
In other words, any router&#8217;s sub-flow returns to the main flow after <code>.route()</code>.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Sometimes, you need to refer to an existing <code>IntegrationFlow</code> <code>@Bean</code> from the <code>.subFlowMapping()</code>.
The following example shows how to do so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Bean
public IntegrationFlow splitRouteAggregate() {
    return f -&gt; f
            .split()
            .&lt;Integer, Boolean&gt;route(o -&gt; o % 2 == 0,
                    m -&gt; m
                            .subFlowMapping(true, oddFlow())
                            .subFlowMapping(false, sf -&gt; sf.gateway(evenFlow())))
            .aggregate();
}

@Bean
public IntegrationFlow oddFlow() {
    return f -&gt; f.handle(m -&gt; System.out.println("odd"));
}

@Bean
public IntegrationFlow evenFlow() {
    return f -&gt; f.handle((p, h) -&gt; "even");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><br>
In this case, when you need to receive a reply from such a sub-flow and continue the main flow, this <code>IntegrationFlow</code> bean reference (or its input channel) has to be wrapped with a <code>.gateway()</code> as shown in the preceding example.
The <code>oddFlow()</code> reference in the preceding example is not wrapped to the <code>.gateway()</code>.
Therefore, we do not expect a reply from this routing branch.
Otherwise, you end up with an exception similar to the following:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Caused by: org.springframework.beans.factory.BeanCreationException:
    The 'currentComponent' (<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="f59a8792db8685879c9b929387949890829a879edb9c9b8190928794819c9a9bdb879a80819087dbb890819d9a91bc9b839a9e9c9b92a79a80819087b5c2ccc3c0">[email&#160;protected]</a>a51c)
    is a one-way 'MessageHandler' and it isn't appropriate to configure 'outputChannel'.
    This is the end of the integration flow.</pre>
</div>
</div>
<div class="paragraph">
<p>When you configure a sub-flow as a lambda, the framework handles the request-reply interaction with the sub-flow and a gateway is not needed.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Sub-flows can be nested to any depth, but we do not recommend doing so.
In fact, even in the router case, adding complex sub-flows within a flow would quickly begin to look like a plate of spaghetti and be difficult for a human to parse.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>In cases where the DSL supports a subflow configuration, when a channel is normally needed for the component being configured, and that subflow starts with a <code>channel()</code> element, the framework implicitly places a <code>bridge()</code> between the component output channel and the flow&#8217;s input channel.
For example, in this <code>filter</code> definition:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">.filter(p -&gt; p instanceof String, e -&gt; e
	.discardFlow(df -&gt; df
                         .channel(MessageChannels.queue())
                         ...)</code></pre>
</div>
</div>
<div class="paragraph">
<p>the Framework internally creates a <code>DirectChannel</code> bean for injecting into the <code>MessageFilter.discardChannel</code>.
Then it wraps the subflow into an <code>IntegrationFlow</code> starting with this implicit channel for the subscription and places a <code>bridge</code> before the <code>channel()</code> specified in the flow.
When an existing <code>IntegrationFlow</code> bean is used as a subflow reference (instead of an inline subflow, e.g. a lambda), there is no such bridge required because the framework can resolve the first channel from the flow bean.
With an inline subflow, the input channel is not yet available.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="java-dsl-protocol-adapters"><a class="anchor" href="#java-dsl-protocol-adapters"></a>Using Protocol Adapters</h3>
<div class="paragraph">
<p>All of the examples shown so far illustrate how the DSL supports a messaging architecture by using the Spring Integration programming model.
However, we have yet to do any real integration.
Doing so requires access to remote resources over HTTP, JMS, AMQP, TCP, JDBC, FTP, SMTP, and so on or access to the local file system.
Spring Integration supports all of these and more.
Ideally, the DSL should offer first class support for all of them, but it is a daunting task to implement all of these and keep up as new adapters are added to Spring Integration.
So the expectation is that the DSL is continually catching up with Spring Integration.</p>
</div>
<div class="paragraph">
<p>Consequently, we provide the high-level API to seamlessly define protocol-specific messaging.
We do so with the factory and builder patterns and with lambdas.
You can think of the factory classes as &#8220;Namespace Factories&#8221;, because they play the same role as the XML namespace for components from the concrete protocol-specific Spring Integration modules.
Currently, Spring Integration Java DSL supports the <code>Amqp</code>, <code>Feed</code>, <code>Jms</code>, <code>Files</code>, <code>(S)Ftp</code>, <code>Http</code>, <code>JPA</code>, <code>MongoDb</code>, <code>TCP/UDP</code>, <code>Mail</code>, <code>WebFlux</code>, and <code>Scripts</code> namespace factories.
The following example shows how to use three of them (<code>Amqp</code>, <code>Jms</code>, and <code>Mail</code>):</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Bean
public IntegrationFlow amqpFlow() {
    return IntegrationFlows.from(Amqp.inboundGateway(this.rabbitConnectionFactory, queue()))
            .transform("hello "::concat)
            .transform(String.class, String::toUpperCase)
            .get();
}

@Bean
public IntegrationFlow jmsOutboundGatewayFlow() {
    return IntegrationFlows.from("jmsOutboundGatewayChannel")
            .handle(Jms.outboundGateway(this.jmsConnectionFactory)
                        .replyContainer(c -&gt;
                                    c.concurrentConsumers(3)
                                            .sessionTransacted(true))
                        .requestDestination("jmsPipelineTest"))
            .get();
}

@Bean
public IntegrationFlow sendMailFlow() {
    return IntegrationFlows.from("sendMailChannel")
            .handle(Mail.outboundAdapter("localhost")
                            .port(smtpPort)
                            .credentials("user", "pw")
                            .protocol("smtp")
                            .javaMailProperties(p -&gt; p.put("mail.debug", "true")),
                    e -&gt; e.id("sendMailEndpoint"))
            .get();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding example shows how to use the &#8220;namespace factories&#8221; as inline adapters declarations.
However, you can use them from <code>@Bean</code> definitions to make the <code>IntegrationFlow</code> method chain more readable.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
We are soliciting community feedback on these namespace factories before we spend effort on others.
We also appreciate any input into prioritization for which adapters and gateways we should support next.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can find more Java DSL samples in the protocol-specific chapters throughout this reference manual.</p>
</div>
<div class="paragraph">
<p>All other protocol channel adapters may be configured as generic beans and wired to the <code>IntegrationFlow</code>, as the following examples show:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Bean
public QueueChannelSpec wrongMessagesChannel() {
    return MessageChannels
            .queue()
            .wireTap("wrongMessagesWireTapChannel");
}

@Bean
public IntegrationFlow xpathFlow(MessageChannel wrongMessagesChannel) {
    return IntegrationFlows.from("inputChannel")
            .filter(new StringValueTestXPathMessageSelector("namespace-uri(/*)", "my:namespace"),
                    e -&gt; e.discardChannel(wrongMessagesChannel))
            .log(LoggingHandler.Level.ERROR, "test.category", m -&gt; m.getHeaders().getId())
            .route(xpathRouter(wrongMessagesChannel))
            .get();
}

@Bean
public AbstractMappingMessageRouter xpathRouter(MessageChannel wrongMessagesChannel) {
    XPathRouter router = new XPathRouter("local-name(/*)");
    router.setEvaluateAsString(true);
    router.setResolutionRequired(false);
    router.setDefaultOutputChannel(wrongMessagesChannel);
    router.setChannelMapping("Tags", "splittingChannel");
    router.setChannelMapping("Tag", "receivedChannel");
    return router;
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="java-dsl-flow-adapter"><a class="anchor" href="#java-dsl-flow-adapter"></a><code>IntegrationFlowAdapter</code></h3>
<div class="paragraph">
<p>The <code>IntegrationFlow</code> interface can be implemented directly and specified as a component for scanning, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Component
public class MyFlow implements IntegrationFlow {

    @Override
    public void configure(IntegrationFlowDefinition&lt;?&gt; f) {
        f.&lt;String, String&gt;transform(String::toUpperCase);
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>It is picked up by the <code>IntegrationFlowBeanPostProcessor</code> and correctly parsed and registered in the application context.</p>
</div>
<div class="paragraph">
<p>For convenience and to gain the benefits of loosely coupled architecture, we provide the <code>IntegrationFlowAdapter</code> base class implementation.
It requires a <code>buildFlow()</code> method implementation to produce an <code>IntegrationFlowDefinition</code> by using one of <code>from()</code> methods, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Component
public class MyFlowAdapter extends IntegrationFlowAdapter {

    private final AtomicBoolean invoked = new AtomicBoolean();

    public Date nextExecutionTime(TriggerContext triggerContext) {
          return this.invoked.getAndSet(true) ? null : new Date();
    }

    @Override
    protected IntegrationFlowDefinition&lt;?&gt; buildFlow() {
        return from(this::messageSource,
                      e -&gt; e.poller(p -&gt; p.trigger(this::nextExecutionTime)))
                 .split(this)
                 .transform(this)
                 .aggregate(a -&gt; a.processor(this, null), null)
                 .enrichHeaders(Collections.singletonMap("thing1", "THING1"))
                 .filter(this)
                 .handle(this)
                 .channel(c -&gt; c.queue("myFlowAdapterOutput"));
    }

    public String messageSource() {
         return "T,H,I,N,G,2";
    }

    @Splitter
    public String[] split(String payload) {
         return StringUtils.commaDelimitedListToStringArray(payload);
    }

    @Transformer
    public String transform(String payload) {
         return payload.toLowerCase();
    }

    @Aggregator
    public String aggregate(List&lt;String&gt; payloads) {
           return payloads.stream().collect(Collectors.joining());
    }

    @Filter
    public boolean filter(@Header Optional&lt;String&gt; thing1) {
            return thing1.isPresent();
    }

    @ServiceActivator
    public String handle(String payload, @Header String thing1) {
           return payload + ":" + thing1;
    }

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="java-dsl-runtime-flows"><a class="anchor" href="#java-dsl-runtime-flows"></a>Dynamic and Runtime Integration Flows</h3>
<div class="paragraph">
<p><code>IntegrationFlow</code> and all its dependent components can be registered at runtime.
Before version 5.0, we used the <code>BeanFactory.registerSingleton()</code> hook.
Starting in the Spring Framework <code>5.0</code>, we use the <code>instanceSupplier</code> hook for programmatic <code>BeanDefinition</code> registration.
The following example shows how to programmatically register a bean:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">BeanDefinition beanDefinition =
         BeanDefinitionBuilder.genericBeanDefinition((Class&lt;Object&gt;) bean.getClass(), () -&gt; bean)
               .getRawBeanDefinition();

((BeanDefinitionRegistry) this.beanFactory).registerBeanDefinition(beanName, beanDefinition);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Note that, in the preceding example, the <code>instanceSupplier</code> hook is the last parameter to the <code>genericBeanDefinition</code> method, provided by a lambda in this case.</p>
</div>
<div class="paragraph">
<p>All the necessary bean initialization and lifecycle is done automatically, as it is with the standard context configuration bean definitions.</p>
</div>
<div class="paragraph">
<p>To simplify the development experience, Spring Integration introduced <code>IntegrationFlowContext</code> to register and manage <code>IntegrationFlow</code> instances at runtime, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Autowired
private AbstractServerConnectionFactory server1;

@Autowired
private IntegrationFlowContext flowContext;

...

@Test
public void testTcpGateways() {
    TestingUtilities.waitListening(this.server1, null);

    IntegrationFlow flow = f -&gt; f
            .handle(Tcp.outboundGateway(Tcp.netClient("localhost", this.server1.getPort())
                    .serializer(TcpCodecs.crlf())
                    .deserializer(TcpCodecs.lengthHeader1())
                    .id("client1"))
                .remoteTimeout(m -&gt; 5000))
            .transform(Transformers.objectToString());

    IntegrationFlowRegistration theFlow = this.flowContext.registration(flow).register();
    assertThat(theFlow.getMessagingTemplate().convertSendAndReceive("foo", String.class), equalTo("FOO"));
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This is useful when we have multiple configuration options and have to create several instances of similar flows.
To do so, we can iterate our options and create and register <code>IntegrationFlow</code> instances within a loop.
Another variant is when our source of data is not Spring-based and we must create it on the fly.
Such a sample is Reactive Streams event source, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Flux&lt;Message&lt;?&gt;&gt; messageFlux =
    Flux.just("1,2,3,4")
        .map(v -&gt; v.split(","))
        .flatMapIterable(Arrays::asList)
        .map(Integer::parseInt)
        .map(GenericMessage&lt;Integer&gt;::new);

QueueChannel resultChannel = new QueueChannel();

IntegrationFlow integrationFlow =
    IntegrationFlows.from(messageFlux)
        .&lt;Integer, Integer&gt;transform(p -&gt; p * 2)
        .channel(resultChannel)
        .get();

this.integrationFlowContext.registration(integrationFlow)
            .register();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>IntegrationFlowRegistrationBuilder</code> (as a result of the <code>IntegrationFlowContext.registration()</code>) can be used to specify a bean name for the <code>IntegrationFlow</code> to register, to control its <code>autoStartup</code>, and to register, non-Spring Integration beans.
Usually, those additional beans are connection factories (AMQP, JMS, (S)FTP, TCP/UDP, and others.), serializers and deserializers, or any other required support components.</p>
</div>
<div class="paragraph">
<p>You can use the <code>IntegrationFlowRegistration.destroy()</code> callback to remove a dynamically registered <code>IntegrationFlow</code> and all its dependent beans when you no longer need them.
See the <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/dsl/context/IntegrationFlowContext.html"><code>IntegrationFlowContext</code> Javadoc</a> for more information.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Starting with version 5.0.6, all generated bean names in an <code>IntegrationFlow</code> definition are prepended with the flow ID as a prefix.
We recommend always specifying an explicit flow ID.
Otherwise, a synchronization barrier is initiated in the <code>IntegrationFlowContext</code>, to generate the bean name for the <code>IntegrationFlow</code> and register its beans.
We synchronize on these two operations to avoid a race condition when the same generated bean name may be used for different <code>IntegrationFlow</code> instances.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Also, starting with version 5.0.6, the registration builder API has a new method: <code>useFlowIdAsPrefix()</code>.
This is useful if you wish to declare multiple instances of the same flow and avoid bean name collisions when components in the flows have the same ID, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">private void registerFlows() {
    IntegrationFlowRegistration flow1 =
              this.flowContext.registration(buildFlow(1234))
                    .id("tcp1")
                    .useFlowIdAsPrefix()
                    .register();

    IntegrationFlowRegistration flow2 =
              this.flowContext.registration(buildFlow(1235))
                    .id("tcp2")
                    .useFlowIdAsPrefix()
                    .register();
}

private IntegrationFlow buildFlow(int port) {
    return f -&gt; f
            .handle(Tcp.outboundGateway(Tcp.netClient("localhost", port)
                    .serializer(TcpCodecs.crlf())
                    .deserializer(TcpCodecs.lengthHeader1())
                    .id("client"))
                .remoteTimeout(m -&gt; 5000))
            .transform(Transformers.objectToString());
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In this case, the message handler for the first flow can be referenced with bean a name of <code>tcp1.client.handler</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
An <code>id</code> attribute is required when you usE <code>useFlowIdAsPrefix()</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="java-dsl-gateway"><a class="anchor" href="#java-dsl-gateway"></a><code>IntegrationFlow</code> as a Gateway</h3>
<div class="paragraph">
<p>The <code>IntegrationFlow</code> can start from the service interface that provides a <code>GatewayProxyFactoryBean</code> component, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public interface ControlBusGateway {

    void send(String command);
}

...

@Bean
public IntegrationFlow controlBusFlow() {
    return IntegrationFlows.from(ControlBusGateway.class)
            .controlBus()
            .get();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>All the proxy for interface methods are supplied with the channel to send messages to the next integration component in the <code>IntegrationFlow</code>.
You can mark the service interface with the <code>@MessagingGateway</code> annotation and mark the methods with the <code>@Gateway</code> annotations.
Nevertheless, the <code>requestChannel</code> is ignored and overridden with that internal channel for the next component in the <code>IntegrationFlow</code>.
Otherwise, creating such a configuration by using <code>IntegrationFlow</code> does not make sense.</p>
</div>
<div class="paragraph">
<p>By default a <code>GatewayProxyFactoryBean</code> gets a conventional bean name, such as <code>[FLOW_BEAN_NAME.gateway]</code>.
You can change that ID by using the <code>@MessagingGateway.name()</code> attribute or the overloaded <code>IntegrationFlows.from(Class&lt;?&gt; serviceInterface, Consumer&lt;GatewayProxySpec&gt; endpointConfigurer)</code> factory method.
Also all the attributes from the <code>@MessagingGateway</code> annotation on the interface are applied to the target <code>GatewayProxyFactoryBean</code>.
When annotation configuration is not applicable, the <code>Consumer&lt;GatewayProxySpec&gt;</code> variant can be used for providing appropriate option for the target proxy.
This DSL method is available starting with version 5.2.</p>
</div>
<div class="paragraph">
<p>With Java 8, you can even create an integration gateway with the <code>java.util.function</code> interfaces, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Bean
public IntegrationFlow errorRecovererFlow() {
    return IntegrationFlows.from(Function.class, (gateway) -&gt; gateway.beanName("errorRecovererFunction"))
            .handle((GenericHandler&lt;?&gt;) (p, h) -&gt; {
                throw new RuntimeException("intentional");
            }, e -&gt; e.advice(retryAdvice()))
            .get();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>That <code>errorRecovererFlow</code> can be used as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Autowired
@Qualifier("errorRecovererFunction")
private Function&lt;String, String&gt; errorRecovererFlowGateway;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="java-dsl-extensions"><a class="anchor" href="#java-dsl-extensions"></a>DSL Extensions</h3>
<div class="paragraph">
<p>Starting with version 5.3, an <code>IntegrationFlowExtension</code> has been introduced to allow extension of the existing Java DSL with custom or composed EIP-operators.
All that is needed is an extension of this class that provides methods which can be used in the <code>IntegrationFlow</code> bean definitions.
The extension class can also be used for custom <code>IntegrationComponentSpec</code> configuration; for example, missed or default options can be implemented in the existing <code>IntegrationComponentSpec</code> extension.
The sample below demonstrates a composite custom operator and usage of an <code>AggregatorSpec</code> extension for a default custom <code>outputProcessor</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class CustomIntegrationFlowDefinition
        extends IntegrationFlowExtension&lt;CustomIntegrationFlowDefinition&gt; {

    public CustomIntegrationFlowDefinition upperCaseAfterSplit() {
        return split()
                .transform("payload.toUpperCase()");
    }

    public CustomIntegrationFlowDefinition customAggregate(Consumer&lt;CustomAggregatorSpec&gt; aggregator) {
        return register(new CustomAggregatorSpec(), aggregator);
    }

}

public class CustomAggregatorSpec extends AggregatorSpec {

    CustomAggregatorSpec() {
        outputProcessor(group -&gt;
                group.getMessages()
                        .stream()
                        .map(Message::getPayload)
                        .map(String.class::cast)
                        .collect(Collectors.joining(", ")));
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>For a method chain flow the new DSL operator in these extensions must return the extension class.
This way a target <code>IntegrationFlow</code> definition will work with new and existing DSL operators:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Bean
public IntegrationFlow customFlowDefinition() {
    return
            new CustomIntegrationFlowDefinition()
                    .log()
                    .upperCaseAfterSplit()
                    .channel("innerChannel")
                    .customAggregate(customAggregatorSpec -&gt;
                            customAggregatorSpec.expireGroupsUponCompletion(true))
                    .logAndReply();
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 5.3.2.RELEASE<br>
Last updated 2020-07-22 17:49:12 UTC
</div>
</div>
<link rel="stylesheet" href="js/highlight/styles/github.min.css">
<script data-cfasync="false" src="/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script src="js/highlight/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>
<script type="text/javascript" src="js/tocbot/tocbot.min.js"></script>
<script type="text/javascript" src="js/toc.js"></script>
<script>if(window.parent==window){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-2728886-23','auto',{'siteSpeedSampleRate':100});ga('send','pageview');}</script></body>
</html>