<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<title>Message Endpoints</title>
<link rel="stylesheet" href="css/spring.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>#header #revnumber{display:none}</style>
</head>
<body class="book toc2 toc-left">
<div id="header">
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel2">
<li><a href="#endpoint">Message Endpoints</a>
<ul class="sectlevel3">
<li><a href="#endpoint-handler">Message Handler</a></li>
<li><a href="#endpoint-eventdrivenconsumer">Event-driven Consumer</a></li>
<li><a href="#endpoint-pollingconsumer">Polling Consumer</a></li>
<li><a href="#endpoint-namespace">Endpoint Namespace Support</a>
<ul class="sectlevel4">
<li><a href="#examples">Examples</a></li>
<li><a href="#aop-advice-chains">AOP Advice chains</a></li>
</ul>
</li>
<li><a href="#polling-consumer-change-polling-rate">Changing Polling Rate at Runtime</a></li>
<li><a href="#payload-type-conversion">Payload Type Conversion</a></li>
<li><a href="#content-type-conversion">Content Type Conversion</a></li>
<li><a href="#async-polling">Asynchronous Polling</a></li>
<li><a href="#endpoint-inner">Endpoint Inner Beans</a></li>
</ul>
</li>
<li><a href="#endpoint-roles">Endpoint Roles</a></li>
<li><a href="#leadership-event-handling">Leadership Event Handling</a></li>
</ul>
</div>
</div>
<div id="content">
<div class="sect2">
<h3 id="endpoint"><a class="anchor" href="#endpoint"></a>Message Endpoints</h3>
<div class="paragraph">
<p>The first part of this chapter covers some background theory and reveals quite a bit about the underlying API that drives Spring Integration&#8217;s various messaging components.
This information can be helpful if you want to really understand what goes on behind the scenes.
However, if you want to get up and running with the simplified namespace-based configuration of the various elements, feel free to skip ahead to <a href="#endpoint-namespace">Endpoint Namespace Support</a> for now.</p>
</div>
<div class="paragraph">
<p>As mentioned in the overview, message endpoints are responsible for connecting the various messaging components to channels.
Over the next several chapters, we cover a number of different components that consume messages.
Some of these are also capable of sending reply messages.
Sending messages is quite straightforward.
As shown earlier in <a href="./channel.html#channel">Message Channels</a>, you can send a message to a message channel.
However, receiving is a bit more complicated.
The main reason is that there are two types of consumers: <a href="https://www.enterpriseintegrationpatterns.com/PollingConsumer.html">polling consumers</a> and <a href="https://www.enterpriseintegrationpatterns.com/EventDrivenConsumer.html">event-driven consumers</a>.</p>
</div>
<div class="paragraph">
<p>Of the two, event-driven consumers are much simpler.
Without any need to manage and schedule a separate poller thread, they are essentially listeners with a callback method.
When connecting to one of Spring Integration&#8217;s subscribable message channels, this simple option works great.
However, when connecting to a buffering, pollable message channel, some component has to schedule and manage the polling threads.
Spring Integration provides two different endpoint implementations to accommodate these two types of consumers.
Therefore, the consumers themselves need only implement the callback interface.
When polling is required, the endpoint acts as a container for the consumer instance.
The benefit is similar to that of using a container for hosting message-driven beans, but, since these consumers are Spring-managed objects running within an <code>ApplicationContext</code>, it more closely resembles Spring&#8217;s own <code>MessageListener</code> containers.</p>
</div>
<div class="sect3">
<h4 id="endpoint-handler"><a class="anchor" href="#endpoint-handler"></a>Message Handler</h4>
<div class="paragraph">
<p>Spring Integration&#8217;s <code>MessageHandler</code> interface is implemented by many of the components within the framework.
In other words, this is not part of the public API, and you would not typically implement <code>MessageHandler</code> directly.
Nevertheless, it is used by a message consumer for actually handling the consumed messages, so being aware of this strategy interface does help in terms of understanding the overall role of a consumer.
The interface is defined as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public interface MessageHandler {

    void handleMessage(Message&lt;?&gt; message);

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Despite its simplicity, this interface provides the foundation for most of the components (routers, transformers, splitters, aggregators, service activators, and others) covered in the following chapters.
Those components each perform very different functionality with the messages they handle, but the requirements for actually receiving a message are the same, and the choice between polling and event-driven behavior is also the same.
Spring Integration provides two endpoint implementations that host these callback-based handlers and let them be connected to message channels.</p>
</div>
</div>
<div class="sect3">
<h4 id="endpoint-eventdrivenconsumer"><a class="anchor" href="#endpoint-eventdrivenconsumer"></a>Event-driven Consumer</h4>
<div class="paragraph">
<p>Because it is the simpler of the two, we cover the event-driven consumer endpoint first.
You may recall that the <code>SubscribableChannel</code> interface provides a <code>subscribe()</code> method and that the method accepts a <code>MessageHandler</code> parameter (as shown in <a href="./channel.html#channel-interfaces-subscribablechannel"><code>SubscribableChannel</code></a>).
The following listing shows the definition of the <code>subscribe</code> method:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">subscribableChannel.subscribe(messageHandler);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Since a handler that is subscribed to a channel does not have to actively poll that channel, this is an event-driven consumer, and the implementation provided by Spring Integration accepts a <code>SubscribableChannel</code> and a <code>MessageHandler</code>, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">SubscribableChannel channel = context.getBean("subscribableChannel", SubscribableChannel.class);

EventDrivenConsumer consumer = new EventDrivenConsumer(channel, exampleHandler);</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="endpoint-pollingconsumer"><a class="anchor" href="#endpoint-pollingconsumer"></a>Polling Consumer</h4>
<div class="paragraph">
<p>Spring Integration also provides a <code>PollingConsumer</code>, and it can be instantiated in the same way except that the channel must implement <code>PollableChannel</code>, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">PollableChannel channel = context.getBean("pollableChannel", PollableChannel.class);

PollingConsumer consumer = new PollingConsumer(channel, exampleHandler);</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
For more information regarding polling consumers, see <a href="./polling-consumer.html#polling-consumer">Poller</a> and <a href="./channel-adapter.html#channel-adapter">Channel Adapter</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>There are many other configuration options for the polling consumer.
For example, the trigger is a required property.
The following example shows how to set the trigger:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">PollingConsumer consumer = new PollingConsumer(channel, handler);

consumer.setTrigger(new IntervalTrigger(30, TimeUnit.SECONDS));</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Spring Integration currently provides two implementations of the <code>Trigger</code> interface: <code>IntervalTrigger</code> and <code>CronTrigger</code>.
The <code>IntervalTrigger</code> is typically defined with a simple interval (in milliseconds) but also supports an <code>initialDelay</code> property and a boolean <code>fixedRate</code> property (the default is <code>false</code>&#8201;&#8212;&#8201;that is, no fixed delay).
The following example sets both properties:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">IntervalTrigger trigger = new IntervalTrigger(1000);
trigger.setInitialDelay(5000);
trigger.setFixedRate(true);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The result of the three settings in the preceding example is a trigger that waits five seconds and then triggers every second.</p>
</div>
<div class="paragraph">
<p>The <code>CronTrigger</code> requires a valid cron expression.
See the <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/scheduling/support/CronTrigger.html">Javadoc</a> for details.
The following example sets a new <code>CronTrigger</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">CronTrigger trigger = new CronTrigger("*/10 * * * * MON-FRI");</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The result of the trigger defined in the previous example is a trigger that triggers every ten seconds, Monday through Friday.</p>
</div>
<div class="paragraph">
<p>In addition to the trigger, you can specify two other polling-related configuration properties: <code>maxMessagesPerPoll</code> and <code>receiveTimeout</code>.
The following example shows how to set these two properties:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">PollingConsumer consumer = new PollingConsumer(channel, handler);

consumer.setMaxMessagesPerPoll(10);
consumer.setReceiveTimeout(5000);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>maxMessagesPerPoll</code> property specifies the maximum number of messages to receive within a given poll operation.
This means that the poller continues calling receive() without waiting, until either <code>null</code> is returned or the maximum value is reached.
For example, if a poller has a ten-second interval trigger and a <code>maxMessagesPerPoll</code> setting of <code>25</code>, and it is polling a channel that has 100 messages in its queue, all 100 messages can be retrieved within 40 seconds.
It grabs 25, waits ten seconds, grabs the next 25, and so on.</p>
</div>
<div class="paragraph">
<p>The <code>receiveTimeout</code> property specifies the amount of time the poller should wait if no messages are available when it invokes the receive operation.
For example, consider two options that seem similar on the surface but are actually quite different: The first has an interval trigger of 5 seconds and a receive timeout of 50 milliseconds, while the second has an interval trigger of 50 milliseconds and a receive timeout of 5 seconds.
The first one may receive a message up to 4950 milliseconds later than it arrived on the channel (if that message arrived immediately after one of its poll calls returned).
On the other hand, the second configuration never misses a message by more than 50 milliseconds.
The difference is that the second option requires a thread to wait.
However, as a result, it can respond much more quickly to arriving messages.
This technique, known as &#8220;long polling&#8221;, can be used to emulate event-driven behavior on a polled source.</p>
</div>
<div class="paragraph">
<p>A polling consumer can also delegate to a Spring <code>TaskExecutor</code>, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">PollingConsumer consumer = new PollingConsumer(channel, handler);

TaskExecutor taskExecutor = context.getBean("exampleExecutor", TaskExecutor.class);
consumer.setTaskExecutor(taskExecutor);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Furthermore, a <code>PollingConsumer</code> has a property called <code>adviceChain</code>.
This property lets you to specify a <code>List</code> of AOP advices for handling additional cross cutting concerns including transactions.
These advices are applied around the <code>doPoll()</code> method.
For more in-depth information, see the sections on AOP advice chains and transaction support under <a href="#endpoint-namespace">Endpoint Namespace Support</a>.</p>
</div>
<div class="paragraph">
<p>The earlier examples show dependency lookups.
However, keep in mind that these consumers are most often configured as Spring bean definitions.
In fact, Spring Integration also provides a <code>FactoryBean</code> called <code>ConsumerEndpointFactoryBean</code> that creates the appropriate consumer type based on the type of channel.
Also, Spring Integration has full XML namespace support to even further hide those details.
The namespace-based configuration is in this guide featured as each component type is introduced.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Many of the <code>MessageHandler</code> implementations can generate reply messages.
As mentioned earlier, sending messages is trivial when compared to receiving messages.
Nevertheless, when and how many reply messages are sent depends on the handler type.
For example, an aggregator waits for a number of messages to arrive and is often configured as a downstream consumer for a splitter, which can generate multiple replies for each message it handles.
When using the namespace configuration, you do not strictly need to know all of the details.
However, it still might be worth knowing that several of these components share a common base class, the <code>AbstractReplyProducingMessageHandler</code>, and that it provides a <code>setOutputChannel(..)</code> method.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="endpoint-namespace"><a class="anchor" href="#endpoint-namespace"></a>Endpoint Namespace Support</h4>
<div class="paragraph">
<p>Throughout this reference manual, you can find specific configuration examples for endpoint elements, such as router, transformer, service-activator, and so on.
Most of these support an <code>input-channel</code> attribute and many support an <code>output-channel</code> attribute.
After being parsed, these endpoint elements produce an instance of either the <code>PollingConsumer</code> or the <code>EventDrivenConsumer</code>, depending on the type of the <code>input-channel</code> that is referenced: <code>PollableChannel</code> or <code>SubscribableChannel</code>, respectively.
When the channel is pollable, the polling behavior is based on the endpoint element&#8217;s <code>poller</code> sub-element and its attributes.</p>
</div>
<div class="paragraph">
<p>The following listing lists all of the available configuration options for a <code>poller</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;int:poller cron=""                                  <i class="conum" data-value="1"></i><b>(1)</b>
            default="false"                          <i class="conum" data-value="2"></i><b>(2)</b>
            error-channel=""                         <i class="conum" data-value="3"></i><b>(3)</b>
            fixed-delay=""                           <i class="conum" data-value="4"></i><b>(4)</b>
            fixed-rate=""                            <i class="conum" data-value="5"></i><b>(5)</b>
            id=""                                    <i class="conum" data-value="6"></i><b>(6)</b>
            max-messages-per-poll=""                 <i class="conum" data-value="7"></i><b>(7)</b>
            receive-timeout=""                       <i class="conum" data-value="8"></i><b>(8)</b>
            ref=""                                   <i class="conum" data-value="9"></i><b>(9)</b>
            task-executor=""                         <i class="conum" data-value="10"></i><b>(10)</b>
            time-unit="MILLISECONDS"                 <i class="conum" data-value="11"></i><b>(11)</b>
            trigger=""&gt;                              <i class="conum" data-value="12"></i><b>(12)</b>
            &lt;int:advice-chain /&gt;                     <i class="conum" data-value="13"></i><b>(13)</b>
            &lt;int:transactional /&gt;                    <i class="conum" data-value="14"></i><b>(14)</b>
&lt;/int:poller&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Provides the ability to configure pollers by using Cron expressions.
The underlying implementation uses an <code>org.springframework.scheduling.support.CronTrigger</code>.
If this attribute is set, none of the following attributes must be specified: <code>fixed-delay</code>, <code>trigger</code>, <code>fixed-rate</code>, and <code>ref</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>By setting this attribute to <code>true</code>, you can define exactly one global default poller.
An exception is raised if more than one default poller is defined in the application context.
Any endpoints connected to a <code>PollableChannel</code> (<code>PollingConsumer</code>) or any <code>SourcePollingChannelAdapter</code> that does not have an explicitly configured poller then uses the global default poller.
It defaults to <code>false</code>.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Identifies the channel to which error messages are sent if a failure occurs in this poller&#8217;s invocation.
To completely suppress exceptions, you can provide a reference to the <code>nullChannel</code>.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The fixed delay trigger uses a <code>PeriodicTrigger</code> under the covers.
If you do not use the <code>time-unit</code> attribute, the specified value is represented in milliseconds.
If this attribute is set, none of the following attributes must be specified: <code>fixed-rate</code>, <code>trigger</code>, <code>cron</code>, and <code>ref</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>The fixed rate trigger uses a <code>PeriodicTrigger</code> under the covers.
If you do not use the <code>time-unit</code> attribute, the specified value is represented in milliseconds.
If this attribute is set, none of the following attributes must be specified: <code>fixed-delay</code>, <code>trigger</code>, <code>cron</code>, and <code>ref</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>The ID referring to the poller&#8217;s underlying bean-definition, which is of type <code>org.springframework.integration.scheduling.PollerMetadata</code>.
The <code>id</code> attribute is required for a top-level poller element, unless it is the default poller (<code>default="true"</code>).</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>See <a href="./channel-adapter.html#channel-adapter-namespace-inbound">Configuring An Inbound Channel Adapter</a> for more information.
If not specified, the default value depends on the context.
If you use a <code>PollingConsumer</code>, this attribute defaults to <code>-1</code>.
However, if you use a <code>SourcePollingChannelAdapter</code>, the <code>max-messages-per-poll</code> attribute defaults to <code>1</code>.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>Value is set on the underlying class <code>PollerMetadata</code>.
If not specified, it defaults to 1000 (milliseconds).
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>Bean reference to another top-level poller.
The <code>ref</code> attribute must not be present on the top-level <code>poller</code> element.
However, if this attribute is set, none of the following attributes must be specified: <code>fixed-rate</code>, <code>trigger</code>, <code>cron</code>, and <code>fixed-delay</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i><b>10</b></td>
<td>Provides the ability to reference a custom task executor.
See <a href="#taskexecutor-support">TaskExecutor Support</a> for further information.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="11"></i><b>11</b></td>
<td>This attribute specifies the <code>java.util.concurrent.TimeUnit</code> enum value on the underlying <code>org.springframework.scheduling.support.PeriodicTrigger</code>.
Therefore, this attribute can be used only in combination with the <code>fixed-delay</code> or <code>fixed-rate</code> attributes.
If combined with either <code>cron</code> or a <code>trigger</code> reference attribute, it causes a failure.
The minimal supported granularity for a <code>PeriodicTrigger</code> is milliseconds.
Therefore, the only available options are milliseconds and seconds.
If this value is not provided, any <code>fixed-delay</code> or <code>fixed-rate</code> value is interpreted as milliseconds.
Basically, this enum provides a convenience for seconds-based interval trigger values.
For hourly, daily, and monthly settings, we recommend using a <code>cron</code> trigger instead.</td>
</tr>
<tr>
<td><i class="conum" data-value="12"></i><b>12</b></td>
<td>Reference to any Spring-configured bean that implements the <code>org.springframework.scheduling.Trigger</code> interface.
However, if this attribute is set, none of the following attributes must be specified: <code>fixed-delay</code>, <code>fixed-rate</code>, <code>cron</code>, and <code>ref</code>.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="13"></i><b>13</b></td>
<td>Allows specifying extra AOP advices to handle additional cross-cutting concerns.
See <a href="#transaction-support">Transaction Support</a> for further information.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="14"></i><b>14</b></td>
<td>Pollers can be made transactional.
See <a href="#aop-advice-chains">AOP Advice chains</a> for further information.
Optional.</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="examples"><a class="anchor" href="#examples"></a>Examples</h5>
<div class="paragraph">
<p>A simple interval-based poller with a 1-second interval can be configured as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;int:transformer input-channel="pollable"
    ref="transformer"
    output-channel="output"&gt;
    &lt;int:poller fixed-rate="1000"/&gt;
&lt;/int:transformer&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>As an alternative to using the <code>fixed-rate</code> attribute, you can also use the <code>fixed-delay</code> attribute.</p>
</div>
<div class="paragraph">
<p>For a poller based on a Cron expression, use the <code>cron</code> attribute instead, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;int:transformer input-channel="pollable"
    ref="transformer"
    output-channel="output"&gt;
    &lt;int:poller cron="*/10 * * * * MON-FRI"/&gt;
&lt;/int:transformer&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If the input channel is a <code>PollableChannel</code>, the poller configuration is required.
Specifically, as mentioned earlier, the <code>trigger</code> is a required property of the <code>PollingConsumer</code> class.
Therefore, if you omit the <code>poller</code> sub-element for a polling consumer endpoint&#8217;s configuration, an exception may be thrown.
The exception may also be thrown if you attempt to configure a poller on the element that is connected to a non-pollable channel.</p>
</div>
<div class="paragraph">
<p>It is also possible to create top-level pollers, in which case only a <code>ref</code> attribute is required, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;int:poller id="weekdayPoller" cron="*/10 * * * * MON-FRI"/&gt;

&lt;int:transformer input-channel="pollable"
    ref="transformer"
    output-channel="output"&gt;
    &lt;int:poller ref="weekdayPoller"/&gt;
&lt;/int:transformer&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>ref</code> attribute is allowed only on the inner poller definitions.
Defining this attribute on a top-level poller results in a configuration exception being thrown during initialization of the application context.
</td>
</tr>
</table>
</div>
<div class="sect5">
<h6 id="global-default-pollers"><a class="anchor" href="#global-default-pollers"></a>Global Default Pollers</h6>
<div class="paragraph">
<p>To simplify the configuration even further, you can define a global default poller.
A single top-level poller within an <code>ApplicationContext</code> may have the <code>default</code> attribute set to <code>true</code>.
In that case, any endpoint with a <code>PollableChannel</code> for its input channel, that is defined within the same <code>ApplicationContext</code>, and has no explicitly configured <code>poller</code> sub-element uses that default.
The following example shows such a poller and a transformer that uses it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;int:poller id="defaultPoller" default="true" max-messages-per-poll="5" fixed-rate="3000"/&gt;

&lt;!-- No &lt;poller/&gt; sub-element is necessary, because there is a default --&gt;
&lt;int:transformer input-channel="pollable"
                 ref="transformer"
                 output-channel="output"/&gt;</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="transaction-support"><a class="anchor" href="#transaction-support"></a>Transaction Support</h6>
<div class="paragraph">
<p>Spring Integration also provides transaction support for the pollers so that each receive-and-forward operation can be performed as an atomic unit of work.
To configure transactions for a poller, add the <code>&lt;transactional/&gt;</code> sub-element.
The following example shows the available attributes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;int:poller fixed-delay="1000"&gt;
    &lt;int:transactional transaction-manager="txManager"
                       propagation="REQUIRED"
                       isolation="REPEATABLE_READ"
                       timeout="10000"
                       read-only="false"/&gt;
&lt;/int:poller&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>For more information, see <a href="./transactions.html#transaction-poller">Poller Transaction Support</a>.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="aop-advice-chains"><a class="anchor" href="#aop-advice-chains"></a>AOP Advice chains</h5>
<div class="paragraph">
<p>Since Spring transaction support depends on the proxy mechanism with <code>TransactionInterceptor</code> (AOP Advice) handling transactional behavior of the message flow initiated by the poller, you must sometimes provide extra advices to handle other cross cutting behavior associated with the poller.
For that, the <code>poller</code> defines an <code>advice-chain</code> element that lets you add more advices in a class that implements the <code>MethodInterceptor</code> interface.
The following example shows how to define an <code>advice-chain</code> for a <code>poller</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;int:service-activator id="advicedSa" input-channel="goodInputWithAdvice" ref="testBean"
		method="good" output-channel="output"&gt;
	&lt;int:poller max-messages-per-poll="1" fixed-rate="10000"&gt;
		 &lt;int:advice-chain&gt;
			&lt;ref bean="adviceA" /&gt;
			&lt;beans:bean class="org.something.SampleAdvice" /&gt;
			&lt;ref bean="txAdvice" /&gt;
		&lt;/int:advice-chain&gt;
	&lt;/int:poller&gt;
&lt;/int:service-activator&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>For more information on how to implement the <code>MethodInterceptor</code> interface, see the <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#aop-api">AOP sections of the Spring Framework Reference Guide</a>.
An advice chain can also be applied on a poller that does not have any transaction configuration, letting you enhance the behavior of the message flow initiated by the poller.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
When using an advice chain, the <code>&lt;transactional/&gt;</code> child element cannot be specified.
Instead, declare a <code>&lt;tx:advice/&gt;</code> bean and add it to the <code>&lt;advice-chain/&gt;</code>.
See <a href="./transactions.html#transaction-poller">Poller Transaction Support</a> for complete configuration details.
</td>
</tr>
</table>
</div>
<div class="sect5">
<h6 id="taskexecutor-support"><a class="anchor" href="#taskexecutor-support"></a>TaskExecutor Support</h6>
<div class="paragraph">
<p>The polling threads may be executed by any instance of Spring&#8217;s <code>TaskExecutor</code> abstraction.
This enables concurrency for an endpoint or group of endpoints.
As of Spring 3.0, the core Spring Framework has a <code>task</code> namespace, and its <code>&lt;executor/&gt;</code> element supports the creation of a simple thread pool executor.
That element accepts attributes for common concurrency settings, such as pool-size and queue-capacity.
Configuring a thread-pooling executor can make a substantial difference in how the endpoint performs under load.
These settings are available for each endpoint, since the performance of an endpoint is one of the major factors to consider (the other major factor being the expected volume on the channel to which the endpoint subscribes).
To enable concurrency for a polling endpoint that is configured with the XML namespace support, provide the <code>task-executor</code> reference on its <code>&lt;poller/&gt;</code> element and then provide one or more of the properties shown in the following example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;int:poller task-executor="pool" fixed-rate="1000"/&gt;

&lt;task:executor id="pool"
               pool-size="5-25"
               queue-capacity="20"
               keep-alive="120"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If you do not provide a task-executor, the consumer&#8217;s handler is invoked in the caller&#8217;s thread.
Note that the caller is usually the default <code>TaskScheduler</code> (see <a href="./configuration.html#namespace-taskscheduler">Configuring the Task Scheduler</a>).
You should also keep in mind that the <code>task-executor</code> attribute can provide a reference to any implementation of Spring&#8217;s <code>TaskExecutor</code> interface by specifying the bean name.
The <code>executor</code> element shown earlier is provided for convenience.</p>
</div>
<div class="paragraph">
<p>As mentioned earlier in the <a href="#endpoint-pollingconsumer">background section for polling consumers</a>, you can also configure a polling consumer in such a way as to emulate event-driven behavior.
With a long <code>receive-timeout</code> and a short <code>interval-trigger</code>, you can ensure a very timely reaction to arriving messages even on a polled message source.
Note that this applies only to sources that have a blocking wait call with a timeout.
For example, the file poller does not block.
Each receive() call returns immediately and either contains new files or not.
Therefore, even if a poller contains a long <code>receive-timeout</code>, that value would never be used in such a scenario.
On the other hand, when using Spring Integration&#8217;s own queue-based channels, the timeout value does have a chance to participate.
The following example shows how a polling consumer can receive messages nearly instantaneously:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;int:service-activator input-channel="someQueueChannel"
    output-channel="output"&gt;
    &lt;int:poller receive-timeout="30000" fixed-rate="10"/&gt;

&lt;/int:service-activator&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Using this approach does not carry much overhead, since, internally, it is nothing more then a timed-wait thread, which does not require nearly as much CPU resource usage as (for example) a thrashing, infinite while loop.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="polling-consumer-change-polling-rate"><a class="anchor" href="#polling-consumer-change-polling-rate"></a>Changing Polling Rate at Runtime</h4>
<div class="paragraph">
<p>When configuring a poller with a <code>fixed-delay</code> or a <code>fixed-rate</code> attribute, the default implementation uses a <code>PeriodicTrigger</code> instance.
The <code>PeriodicTrigger</code> is part of the core Spring Framework.
It accepts the interval only as a constructor argument.
Therefore, it cannot be changed at runtime.</p>
</div>
<div class="paragraph">
<p>However, you can define your own implementation of the <code>org.springframework.scheduling.Trigger</code> interface.
You could even use the <code>PeriodicTrigger</code> as a starting point.
Then you can add a setter for the interval (period), or you can even embed your own throttling logic within the trigger itself.
The <code>period</code> property is used with each call to <code>nextExecutionTime</code> to schedule the next poll.
To use this custom trigger within pollers, declare the bean definition of the custom trigger in your application context and inject the dependency into your poller configuration by using the <code>trigger</code> attribute, which references the custom trigger bean instance.
You can now obtain a reference to the trigger bean and change the polling interval between polls.</p>
</div>
<div class="paragraph">
<p>For an example, see the <a href="https://github.com/SpringSource/spring-integration-samples/tree/master/intermediate">Spring Integration Samples</a> project.
It contains a sample called <code>dynamic-poller</code>, which uses a custom trigger and demonstrates the ability to change the polling interval at runtime.</p>
</div>
<div class="paragraph">
<p>The sample provides a custom trigger that implements the <a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/scheduling/Trigger.html"><code>org.springframework.scheduling.Trigger</code></a> interface.
The sample&#8217;s trigger is based on Spring&#8217;s <a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/scheduling/support/PeriodicTrigger.html"><code>PeriodicTrigger</code></a> implementation.
However, the fields of the custom trigger are not final, and the properties have explicit getters and setters, letting you dynamically change the polling period at runtime.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
It is important to note, though, that because the Trigger method is <code>nextExecutionTime()</code>, any changes to a dynamic trigger do not take effect until the next poll, based on the existing configuration.
It is not possible to force a trigger to fire before its currently configured next execution time.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="payload-type-conversion"><a class="anchor" href="#payload-type-conversion"></a>Payload Type Conversion</h4>
<div class="paragraph">
<p>Throughout this reference manual, you can also see specific configuration and implementation examples of various endpoints that accept a message or any arbitrary <code>Object</code> as an input parameter.
In the case of an <code>Object</code>, such a parameter is mapped to a message payload or part of the payload or header (when using the Spring Expression Language).
However, the type of input parameter of the endpoint method sometimes does not match the type of the payload or its part.
In this scenario, we need to perform type conversion.
Spring Integration provides a convenient way for registering type converters (by using the Spring <code>ConversionService</code>) within its own instance of a conversion service bean named <code>integrationConversionService</code>.
That bean is automatically created as soon as the first converter is defined by using the Spring Integration infrastructure.
To register a converter, you can implement <code>org.springframework.core.convert.converter.Converter</code>, <code>org.springframework.core.convert.converter.GenericConverter</code>, or <code>org.springframework.core.convert.converter.ConverterFactory</code>.</p>
</div>
<div class="paragraph">
<p>The <code>Converter</code> implementation is the simplest and converts from a single type to another.
For more sophistication, such as converting to a class hierarchy, you can implement a <code>GenericConverter</code> and possibly a <code>ConditionalConverter</code>.
These give you complete access to the <code>from</code> and <code>to</code> type descriptors, enabling complex conversions.
For example, if you have an abstract class called <code>Something</code> that is the target of your conversion (parameter type, channel data type, and so on), you have two concrete implementations called <code>Thing1</code> and <code>Thing</code>, and you wish to convert to one or the other based on the input type, the <code>GenericConverter</code> would be a good fit.
For more information, see the Javadoc for these interfaces:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/convert/converter/Converter.html">org.springframework.core.convert.converter.Converter</a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/convert/converter/package-summary.html">org.springframework.core.convert.converter.GenericConverter</a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/core/convert/converter/ConverterFactory.html">org.springframework.core.convert.converter.ConverterFactory</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When you have implemented your converter, you can register it with convenient namespace support, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;int:converter ref="sampleConverter"/&gt;

&lt;bean id="sampleConverter" class="foo.bar.TestConverter"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Alternately, you can use an inner bean, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;int:converter&gt;
    &lt;bean class="o.s.i.config.xml.ConverterParserTests$TestConverter3"/&gt;
&lt;/int:converter&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Starting with Spring Integration 4.0, you can use annotations to create the preceding configuration, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Component
@IntegrationConverter
public class TestConverter implements Converter&lt;Boolean, Number&gt; {

	public Number convert(Boolean source) {
		return source ? 1 : 0;
	}

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Alternately, you can use the <code>@Configuration</code> annotation, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configuration
@EnableIntegration
public class ContextConfiguration {

	@Bean
	@IntegrationConverter
	public SerializingConverter serializingConverter() {
		return new SerializingConverter();
	}

}</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When configuring an application context, the Spring Framework lets you add a <code>conversionService</code> bean (see <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#core-convert-Spring-config">Configuring a ConversionService</a> chapter).
This service is used, when needed, to perform appropriate conversions during bean creation and configuration.</p>
</div>
<div class="paragraph">
<p>In contrast, the <code>integrationConversionService</code> is used for runtime conversions.
These uses are quite different.
Converters that are intended for use when wiring bean constructor arguments and properties may produce unintended results if used at runtime for Spring Integration expression evaluation against messages within data type channels, payload type transformers, and so on.</p>
</div>
<div class="paragraph">
<p>However, if you do want to use the Spring <code>conversionService</code> as the Spring Integration <code>integrationConversionService</code>, you can configure an alias in the application context, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;alias name="conversionService" alias="integrationConversionService"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In this case, the converters provided by the <code>conversionService</code> are available for Spring Integration runtime conversion.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="content-type-conversion"><a class="anchor" href="#content-type-conversion"></a>Content Type Conversion</h4>
<div class="paragraph">
<p>Starting with version 5.0, by default, the method invocation mechanism is based on the <code>org.springframework.messaging.handler.invocation.InvocableHandlerMethod</code> infrastructure.
Its <code>HandlerMethodArgumentResolver</code> implementations (such as <code>PayloadArgumentResolver</code> and <code>MessageMethodArgumentResolver</code>) can use the <code>MessageConverter</code> abstraction to convert an incoming <code>payload</code> to the target method argument type.
The conversion can be based on the <code>contentType</code> message header.
For this purpose, Spring Integration provides the <code>ConfigurableCompositeMessageConverter</code>, which delegates to a list of registered converters to be invoked until one of them returns a non-null result.
By default, this converter provides (in strict order):</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/jms/support/converter/MappingJackson2MessageConverter.html"><code>MappingJackson2MessageConverter</code></a> if the Jackson processor is present on the classpath</p>
</li>
<li>
<p><a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/messaging/converter/ByteArrayMessageConverter.html"><code>ByteArrayMessageConverter</code></a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-integration/docs/current/api//org/springframework/integration/support/converter/ObjectStringMessageConverter.html"><code>ObjectStringMessageConverter</code></a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/messaging/converter/GenericMessageConverter.html"><code>GenericMessageConverter</code></a></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>See the Javadoc (linked in the preceding list) for more information about their purpose and appropriate <code>contentType</code> values for conversion.
The <code>ConfigurableCompositeMessageConverter</code> is used because it can be be supplied with any other <code>MessageConverter</code> implementations, including or excluding the previously mentioned default converters.
It can also be registered as an appropriate bean in the application context, overriding the default converter, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Bean(name = IntegrationContextUtils.ARGUMENT_RESOLVER_MESSAGE_CONVERTER_BEAN_NAME)
public ConfigurableCompositeMessageConverter compositeMessageConverter() {
    List&lt;MessageConverter&gt; converters =
        Arrays.asList(new MarshallingMessageConverter(jaxb2Marshaller()),
                 new JavaSerializationMessageConverter());
    return new ConfigurableCompositeMessageConverter(converters);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Those two new converters are registered in the composite before the defaults.
You can also not use a <code>ConfigurableCompositeMessageConverter</code> but provide your own <code>MessageConverter</code> by registering a bean with the name, <code>integrationArgumentResolverMessageConverter</code> (by setting the <code>IntegrationContextUtils.ARGUMENT_RESOLVER_MESSAGE_CONVERTER_BEAN_NAME</code> property).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>MessageConverter</code>-based (including <code>contentType</code> header) conversion is not available when using SpEL method invocation.
In this case, only the regular class-to-class conversion mentioned above in the <a href="#payload-type-conversion">Payload Type Conversion</a> is available.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="async-polling"><a class="anchor" href="#async-polling"></a>Asynchronous Polling</h4>
<div class="paragraph">
<p>If you want the polling to be asynchronous, a poller can optionally specify a <code>task-executor</code> attribute that points to an existing instance of any <code>TaskExecutor</code> bean (Spring 3.0 provides a convenient namespace configuration through the <code>task</code> namespace).
However, there are certain things you must understand when configuring a poller with a <code>TaskExecutor</code>. </p>
</div>
<div class="paragraph">
<p>The problem is that there are two configurations in place, the poller and the <code>TaskExecutor</code>.
They must be in tune with each other.
Otherwise, you might end up creating an artificial memory leak.</p>
</div>
<div class="paragraph">
<p>Consider the following configuration:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;int:channel id="publishChannel"&gt;
    &lt;int:queue /&gt;
&lt;/int:channel&gt;

&lt;int:service-activator input-channel="publishChannel" ref="myService"&gt;
	&lt;int:poller receive-timeout="5000" task-executor="taskExecutor" fixed-rate="50" /&gt;
&lt;/int:service-activator&gt;

&lt;task:executor id="taskExecutor" pool-size="20" /&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding configuration demonstrates an out-of-tune configuration.</p>
</div>
<div class="paragraph">
<p>By default, the task executor has an unbounded task queue.
The poller keeps scheduling new tasks even though all the threads are blocked, waiting for either a new message to arrive or the timeout to expire.
Given that there are 20 threads executing tasks with a five-second timeout, they are executed at a rate of 4 per second.
However, new tasks are being scheduled at a rate of 20 per second, so the internal queue in the task executor grows at a rate of 16 per second (while the process is idle), so we have a memory leak.</p>
</div>
<div class="paragraph">
<p>One of the ways to handle this is to set the <code>queue-capacity</code> attribute of the task executor.
Even 0 is a reasonable value.
You can also manage it by specifying what to do with messages that can not be queued by setting the <code>rejection-policy</code> attribute of the Task Executor (for example, to <code>DISCARD</code>).
In other words, there are certain details you must understand when configuring <code>TaskExecutor</code>.
See <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#scheduling">&#8220;Task Execution and Scheduling&#8221;</a> in the Spring reference manual for more detail on the subject.</p>
</div>
</div>
<div class="sect3">
<h4 id="endpoint-inner"><a class="anchor" href="#endpoint-inner"></a>Endpoint Inner Beans</h4>
<div class="paragraph">
<p>Many endpoints are composite beans.
This includes all consumers and all polled inbound channel adapters.
Consumers (polled or event-driven) delegate to a <code>MessageHandler</code>.
Polled adapters obtain messages by delegating to a <code>MessageSource</code>.
Often, it is useful to obtain a reference to the delegate bean, perhaps to change configuration at runtime or for testing.
These beans can be obtained from the <code>ApplicationContext</code> with well known names.
<code>MessageHandler</code> instances are registered with the application context with bean IDs similar to <code>someConsumer.handler</code> (where 'consumer' is the value of the endpoint&#8217;s <code>id</code> attribute).
<code>MessageSource</code> instances are registered with bean IDs similar to <code>somePolledAdapter.source</code>, where 'somePolledAdapter' is the ID of the adapter.</p>
</div>
<div class="paragraph">
<p>The preceding only applies to the framework component itself.
You can instead use an inner bean definition, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;int:service-activator id="exampleServiceActivator" input-channel="inChannel"
            output-channel = "outChannel" method="foo"&gt;
    &lt;beans:bean class="org.foo.ExampleServiceActivator"/&gt;
&lt;/int:service-activator&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The bean is treated like any inner bean declared and is not registered with the application context.
If you wish to access this bean in some other manner, declare it at the top level with an <code>id</code> and use the <code>ref</code> attribute instead.
See the <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-inner-beans">Spring Documentation</a> for more information.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="endpoint-roles"><a class="anchor" href="#endpoint-roles"></a>Endpoint Roles</h3>
<div class="paragraph">
<p>Starting with version 4.2, endpoints can be assigned to roles.
Roles let endpoints be started and stopped as a group.
This is particularly useful when using leadership election, where a set of endpoints can be started or stopped when leadership is granted or revoked, respectively.
For this purpose the framework registers a <code>SmartLifecycleRoleController</code> bean in the application context with the name <code>IntegrationContextUtils.INTEGRATION_LIFECYCLE_ROLE_CONTROLLER</code>.
Whenever it is necessary to control lifecycles, this bean can be injected or <code>@Autowired</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean class="com.some.project.SomeLifecycleControl"&gt;
    &lt;property name="roleController" ref="integrationLifecycleRoleController"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can assign endpoints to roles using XML, Java configuration, or programmatically.
The following example shows how to configure endpoint roles with XML:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;int:inbound-channel-adapter id="ica" channel="someChannel" expression="'foo'" role="cluster"
        auto-startup="false"&gt;
    &lt;int:poller fixed-rate="60000" /&gt;
&lt;/int:inbound-channel-adapter&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to configure endpoint roles for a bean created in Java:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Bean
@ServiceActivator(inputChannel = "sendAsyncChannel", autoStartup="false")
@Role("cluster")
public MessageHandler sendAsyncHandler() {
    return // some MessageHandler
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to configure endpoint roles on a method in Java:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Payload("#args[0].toLowerCase()")
@Role("cluster")
public String handle(String payload) {
    return payload.toUpperCase();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to configure endpoint roles by using the <code>SmartLifecycleRoleController</code> in Java:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Autowired
private SmartLifecycleRoleController roleController;
...
    this.roleController.addSmartLifeCycleToRole("cluster", someEndpoint);
...</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to configure endpoint roles by using an <code>IntegrationFlow</code> in Java:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">IntegrationFlow flow -&gt; flow
        .handle(..., e -&gt; e.role("cluster"));</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Each of these adds the endpoint to the <code>cluster</code> role.</p>
</div>
<div class="paragraph">
<p>Invoking <code>roleController.startLifecyclesInRole("cluster")</code> and the corresponding <code>stop&#8230;&#8203;</code> method starts and stops the endpoints.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Any object that implements <code>SmartLifecycle</code> can be programmatically added&#8201;&#8212;&#8201;not just endpoints.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>SmartLifecycleRoleController</code> implements <code>ApplicationListener&lt;AbstractLeaderEvent&gt;</code> and it automatically starts and stops its configured <code>SmartLifecycle</code> objects when leadership is granted or revoked (when some bean publishes <code>OnGrantedEvent</code> or <code>OnRevokedEvent</code>, respectively).</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
When using leadership election to start and stop components, it is important to set the <code>auto-startup</code> XML attribute (<code>autoStartup</code> bean property) to <code>false</code> so that the application context does not start the components during context initialization.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Starting with version 4.3.8, the <code>SmartLifecycleRoleController</code> provides several status methods:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public Collection&lt;String&gt; getRoles() <i class="conum" data-value="1"></i><b>(1)</b>

public boolean allEndpointsRunning(String role) <i class="conum" data-value="2"></i><b>(2)</b>

public boolean noEndpointsRunning(String role) <i class="conum" data-value="3"></i><b>(3)</b>

public Map&lt;String, Boolean&gt; getEndpointsRunningStatus(String role) <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Returns a list of the roles being managed.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Returns <code>true</code> if all endpoints in the role are running.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Returns <code>true</code> if none of the endpoints in the role are running.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Returns a map of <code>component name : running status</code>.
The component name is usually the bean name.</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="leadership-event-handling"><a class="anchor" href="#leadership-event-handling"></a>Leadership Event Handling</h3>
<div class="paragraph">
<p>Groups of endpoints can be started and stopped based on leadership being granted or revoked, respectively.
This is useful in clustered scenarios where shared resources must be consumed by only a single instance.
An example of this is a file inbound channel adapter that is polling a shared directory.
(See <a href="./file.html#file-reading">Reading Files</a>).</p>
</div>
<div class="paragraph">
<p>To participate in a leader election and be notified when elected leader, when leadership is revoked, or on failure to acquire the resources to become leader, an application creates a component in the application context called a &#8220;leader initiator&#8221;.
Normally, a leader initiator is a <code>SmartLifecycle</code>, so it starts (optionally) when the context starts and then publishes notifications when leadership changes.
You can also receive failure notifications by setting the <code>publishFailedEvents</code> to <code>true</code> (starting with version 5.0), for cases when you want take a specific action if a failure occurs.
By convention, you should provide a <code>Candidate</code> that receives the callbacks.
You can also revoke the leadership through a <code>Context</code> object provided by the framework.
Your code can also listen for <code>o.s.i.leader.event.AbstractLeaderEvent</code> instances (the super class of <code>OnGrantedEvent</code> and <code>OnRevokedEvent</code>) and respond accordingly (for instance, by using a <code>SmartLifecycleRoleController</code>).
The events contain a reference to the <code>Context</code> object.
The following listing shows the definition of the <code>Context</code> interface:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public interface Context {

	boolean isLeader();

	void yield();

	String getRole();

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Starting with version 5.0.6, the context provides a reference to the candidate&#8217;s role.</p>
</div>
<div class="paragraph">
<p>Spring Integration provides a basic implementation of a leader initiator that is based on the <code>LockRegistry</code> abstraction.
To use it, you need to create an instance as a bean, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Bean
public LockRegistryLeaderInitiator leaderInitiator(LockRegistry locks) {
    return new LockRegistryLeaderInitiator(locks);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If the lock registry is implemented correctly, there is only ever at most one leader.
If the lock registry also provides locks that throw exceptions (ideally, <code>InterruptedException</code>) when they expire or are broken, the duration of the leaderless periods can be as short as is allowed by the inherent latency in the lock implementation.
By default, the <code>busyWaitMillis</code> property adds some additional latency to prevent CPU starvation in the (more usual) case that the locks are imperfect and you only know they expired when you try to obtain one again.</p>
</div>
<div class="paragraph">
<p>See <a href="./zookeeper.html#zk-leadership">Zookeeper Leadership Event Handling</a> for more information about leadership election and events that use Zookeeper.</p>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 5.3.2.RELEASE<br>
Last updated 2020-07-22 17:49:12 UTC
</div>
</div>
<link rel="stylesheet" href="js/highlight/styles/github.min.css">
<script src="js/highlight/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>
<script type="text/javascript" src="js/tocbot/tocbot.min.js"></script>
<script type="text/javascript" src="js/toc.js"></script>
<script>if(window.parent==window){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-2728886-23','auto',{'siteSpeedSampleRate':100});ga('send','pageview');}</script></body>
</html>