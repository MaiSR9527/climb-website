<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<title>JDBC Support</title>
<link rel="stylesheet" href="css/spring.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>#header #revnumber{display:none}</style>
</head>
<body class="book toc2 toc-left">
<div id="header">
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#jdbc">JDBC Support</a>
<ul class="sectlevel2">
<li><a href="#jdbc-inbound-channel-adapter">Inbound Channel Adapter</a>
<ul class="sectlevel3">
<li><a href="#jdbc-polling-transactions">Polling and Transactions</a></li>
<li><a href="#jdbc-max-rows-versus-max-messages-per-poll"><code>max-rows</code> Versus <code>max-messages-per-poll</code></a></li>
</ul>
</li>
<li><a href="#jdbc-outbound-channel-adapter">Outbound Channel Adapter</a>
<ul class="sectlevel3">
<li><a href="#passing-parameters-by-using-spel-expressions">Passing Parameters by Using SpEL Expressions</a></li>
<li><a href="#using-the-preparedstatement-callback">Using the <code>PreparedStatement</code> Callback</a></li>
<li><a href="#batch-update">Batch Update</a></li>
</ul>
</li>
<li><a href="#jdbc-outbound-gateway">Outbound Gateway</a></li>
<li><a href="#jdbc-message-store">JDBC Message Store</a>
<ul class="sectlevel3">
<li><a href="#initializing-the-database">Initializing the Database</a></li>
<li><a href="#jdbc-message-store-generic">The Generic JDBC Message Store</a></li>
<li><a href="#jdbc-message-store-channels">Backing Message Channels</a>
<ul class="sectlevel4">
<li><a href="#supported-databases">Supported Databases</a></li>
<li><a href="#custom-message-insertion">Custom Message Insertion</a></li>
<li><a href="#concurrent-polling">Concurrent Polling</a></li>
<li><a href="#priority-channel">Priority Channel</a></li>
</ul>
</li>
<li><a href="#partitioning-a-message-store">Partitioning a Message Store</a></li>
</ul>
</li>
<li><a href="#stored-procedures">Stored Procedures</a>
<ul class="sectlevel3">
<li><a href="#sp-supported-databases">Supported Databases</a></li>
<li><a href="#sp-configuration">Configuration</a></li>
<li><a href="#sp-common-config-params">Common Configuration Attributes</a></li>
<li><a href="#sp-common-config-subelements">Common Configuration Sub-Elements</a></li>
<li><a href="#sp-defining-parameter-sources">Defining Parameter Sources</a></li>
<li><a href="#stored-procedure-inbound-channel-adapter">Stored Procedure Inbound Channel Adapter</a></li>
<li><a href="#stored-procedure-outbound-channel-adapter">Stored Procedure Outbound Channel Adapter</a></li>
<li><a href="#stored-procedure-outbound-gateway">Stored Procedure Outbound Gateway</a></li>
<li><a href="#sp-examples">Examples</a></li>
</ul>
</li>
<li><a href="#jdbc-lock-registry">JDBC Lock Registry</a></li>
<li><a href="#jdbc-metadata-store">JDBC Metadata Store</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="jdbc"><a class="anchor" href="#jdbc"></a>JDBC Support</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Integration provides channel adapters for receiving and sending messages by using database queries.
Through those adapters, Spring Integration supports not only plain JDBC SQL queries but also stored procedure and stored function calls.</p>
</div>
<div class="paragraph">
<p>You need to include this dependency into your project:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">Maven</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.integration&lt;/groupId&gt;
    &lt;artifactId&gt;spring-integration-jdbc&lt;/artifactId&gt;
    &lt;version&gt;5.3.2.RELEASE&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="groovy" class="language-groovy hljs">compile "org.springframework.integration:spring-integration-jdbc:5.3.2.RELEASE"</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>By default, the following JDBC components are available:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#jdbc-inbound-channel-adapter">Inbound Channel Adapter</a></p>
</li>
<li>
<p><a href="#jdbc-outbound-channel-adapter">Outbound Channel Adapter</a></p>
</li>
<li>
<p><a href="#jdbc-outbound-gateway">Outbound Gateway</a></p>
</li>
<li>
<p><a href="#stored-procedure-inbound-channel-adapter">Stored Procedure Inbound Channel Adapter</a></p>
</li>
<li>
<p><a href="#stored-procedure-outbound-channel-adapter">Stored Procedure Outbound Channel Adapter</a></p>
</li>
<li>
<p><a href="#stored-procedure-outbound-gateway">Stored Procedure Outbound Gateway</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The Spring Integration JDBC Module also provides a <a href="#jdbc-message-store">JDBC Message Store</a>.</p>
</div>
<div class="sect2">
<h3 id="jdbc-inbound-channel-adapter"><a class="anchor" href="#jdbc-inbound-channel-adapter"></a>Inbound Channel Adapter</h3>
<div class="paragraph">
<p>The main function of an inbound channel adapter is to execute a SQL <code>SELECT</code> query and turn the result set into a message.
The message payload is the whole result set (expressed as a <code>List</code>), and the types of the items in the list depend on the row-mapping strategy.
The default strategy is a generic mapper that returns a <code>Map</code> for each row in the query result.
Optionally, you can change this by adding a reference to a <code>RowMapper</code> instance (see the <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/jdbc.html">Spring JDBC</a> documentation for more detailed information about row mapping).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you want to convert rows in the <code>SELECT</code> query result to individual messages, you can use a downstream splitter.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The inbound adapter also requires a reference to either a <code>JdbcTemplate</code> instance or a <code>DataSource</code>.</p>
</div>
<div class="paragraph">
<p>As well as the <code>SELECT</code> statement to generate the messages, the adapter also has an <code>UPDATE</code> statement that marks the records as processed so that they do not show up in the next poll.
The update can be parameterized by the list of IDs from the original select.
By default, this is done through a naming convention (a column in the input result set called <code>id</code> is translated into a list in the parameter map for the update called <code>id</code>).
The following example defines an inbound channel adapter with an update query and a <code>DataSource</code> reference.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;int-jdbc:inbound-channel-adapter query="select * from item where status=2"
    channel="target" data-source="dataSource"
    update="update item set status=10 where id in (:id)" /&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The parameters in the update query are specified with a colon (<code>:</code>) prefix to the name of a parameter (which, in the preceding example, is an expression to be applied to each of the rows in the polled result set).
This is a standard feature of the named parameter JDBC support in Spring JDBC, combined with a convention (projection onto the polled result list) adopted in Spring Integration.
The underlying Spring JDBC features limit the available expressions (for example, most special characters other than a period are disallowed), but since the target is usually a list of objects (possibly a list of one) that are addressable by bean paths this is not unduly restrictive.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To change the parameter generation strategy, you can inject a <code>SqlParameterSourceFactory</code> into the adapter to override the default behavior (the adapter has a <code>sql-parameter-source-factory</code> attribute).
Spring Integration provides <code>ExpressionEvaluatingSqlParameterSourceFactory</code>, which creates a SpEL-based parameter source, with the results of the query as the <code>#root</code> object.
(If <code>update-per-row</code> is true, the root object is the row).
If the same parameter name appears multiple times in the update query, it is evaluated only once, and its result is cached.</p>
</div>
<div class="paragraph">
<p>You can also use a parameter source for the select query.
In this case, since there is no &#8220;result&#8221; object to evaluate against, a single parameter source is used each time (rather than using a parameter source factory).
Starting with version 4.0, you can use Spring to create a SpEL based parameter source, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;int-jdbc:inbound-channel-adapter query="select * from item where status=:status"
	channel="target" data-source="dataSource"
	select-sql-parameter-source="parameterSource" /&gt;

&lt;bean id="parameterSource" factory-bean="parameterSourceFactory"
			factory-method="createParameterSourceNoCache"&gt;
	&lt;constructor-arg value="" /&gt;
&lt;/bean&gt;

&lt;bean id="parameterSourceFactory"
		class="o.s.integration.jdbc.ExpressionEvaluatingSqlParameterSourceFactory"&gt;
	&lt;property name="parameterExpressions"&gt;
		&lt;map&gt;
			&lt;entry key="status" value="@statusBean.which()" /&gt;
		&lt;/map&gt;
	&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="statusBean" class="foo.StatusDetermination" /&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>value</code> in each parameter expression can be any valid SpEL expression.
The <code>#root</code> object for the expression evaluation is the constructor argument defined on the <code>parameterSource</code> bean.
It is static for all evaluations (in the preceding example, an empty <code>String</code>).</p>
</div>
<div class="paragraph">
<p>Starting with version 5.0, you ca supply <code>ExpressionEvaluatingSqlParameterSourceFactory</code> with <code>sqlParameterTypes</code> to specify the target SQL type for the particular parameter.</p>
</div>
<div class="paragraph">
<p>The following example provides SQL types for the parameters being used in the query:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;int-jdbc:inbound-channel-adapter query="select * from item where status=:status"
    channel="target" data-source="dataSource"
    select-sql-parameter-source="parameterSource" /&gt;

&lt;bean id="parameterSource" factory-bean="parameterSourceFactory"
            factory-method="createParameterSourceNoCache"&gt;
    &lt;constructor-arg value="" /&gt;
&lt;/bean&gt;

&lt;bean id="parameterSourceFactory"
        class="o.s.integration.jdbc.ExpressionEvaluatingSqlParameterSourceFactory"&gt;
    &lt;property name="sqlParameterTypes"&gt;
        &lt;map&gt;
            &lt;entry key="status" value="#{ T(java.sql.Types).BINARY}" /&gt;
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Use the <code>createParameterSourceNoCache</code> factory method.
Otherwise, the parameter source caches the result of the evaluation.
Also note that, because caching is disabled, if the same parameter name appears in the select query multiple times, it is re-evaluated for each occurrence.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="jdbc-polling-transactions"><a class="anchor" href="#jdbc-polling-transactions"></a>Polling and Transactions</h4>
<div class="paragraph">
<p>The inbound adapter accepts a regular Spring Integration poller as a child element.
Consequently, the frequency of the polling can be controlled (among other uses).
An important feature of the poller for JDBC usage is the option to wrap the poll operation in a transaction, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;int-jdbc:inbound-channel-adapter query="..."
        channel="target" data-source="dataSource" update="..."&gt;
    &lt;int:poller fixed-rate="1000"&gt;
        &lt;int:transactional/&gt;
    &lt;/int:poller&gt;
&lt;/int-jdbc:inbound-channel-adapter&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you do not explicitly specify a poller, a default value is used.
As is normal with Spring Integration, it can be defined as a top-level bean).
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In the preceding example, the database is polled every 1000 milliseconds (or once a second), and the update and select queries are both executed in the same transaction.
The transaction manager configuration is not shown.
However, as long as it is aware of the data source, the poll is transactional.
A common use case is for the downstream channels to be direct channels (the default), so that the endpoints are invoked in the same thread and, hence, the same transaction.
That way, if any of them fail, the transaction rolls back and the input data is reverted to its original state.</p>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-max-rows-versus-max-messages-per-poll"><a class="anchor" href="#jdbc-max-rows-versus-max-messages-per-poll"></a><code>max-rows</code> Versus <code>max-messages-per-poll</code></h4>
<div class="paragraph">
<p>The JDBC inbound channel adapter defines an attribute called <code>max-rows</code>.
When you specify the adapter&#8217;s poller, you can also define a property called <code>max-messages-per-poll</code>.
While these two attributes look similar, their meaning is quite different.</p>
</div>
<div class="paragraph">
<p><code>max-messages-per-poll</code> specifies the number of times the query is executed per polling interval, whereas <code>max-rows</code> specifies the number of rows returned for each execution.</p>
</div>
<div class="paragraph">
<p>Under normal circumstances, you would likely not want to set the poller&#8217;s <code>max-messages-per-poll</code> property when you use the JDBC inbound channel adapter.
Its default value is <code>1</code>, which means that the JDBC inbound channel adapter&#8217;s <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/jdbc/JdbcPollingChannelAdapter.html#receive()"><code>receive()</code></a> method is executed exactly once for each poll interval.</p>
</div>
<div class="paragraph">
<p>Setting the <code>max-messages-per-poll</code> attribute to a larger value means that the query is executed that many times back to back.
For more information regarding the <code>max-messages-per-poll</code> attribute, see <a href="./channel-adapter.html#channel-adapter-namespace-inbound">Configuring An Inbound Channel Adapter</a>.</p>
</div>
<div class="paragraph">
<p>In contrast, the <code>max-rows</code> attribute, if greater than <code>0</code>, specifies the maximum number of rows to be used from the query result set created by the <code>receive()</code> method.
If the attribute is set to <code>0</code>, all rows are included in the resulting message.
The attribute defaults to <code>0</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
It is recommended to use result set limiting via vendor-specific query options, for example MySQL <code>LIMIT</code> or SQL Server <code>TOP</code> or Oracle&#8217;s <code>ROWNUM</code>.
See the particular vendor documentation for more information.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jdbc-outbound-channel-adapter"><a class="anchor" href="#jdbc-outbound-channel-adapter"></a>Outbound Channel Adapter</h3>
<div class="paragraph">
<p>The outbound channel adapter is the inverse of the inbound: its role is to handle a message and use it to execute a SQL query.
By default, the message payload and headers are available as input parameters to the query, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;int-jdbc:outbound-channel-adapter
    query="insert into foos (id, status, name) values (:headers[id], 0, :payload[something])"
    data-source="dataSource"
    channel="input"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, messages arriving on the channel labelled <code>input</code> have a payload of a map with a key of <code>something</code>, so the <code>[]</code> operator dereferences that value from the map.
The headers are also accessed as a map.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The parameters in the preceding query are bean property expressions on the incoming message (not SpEL expressions).
This behavior is part of the <code>SqlParameterSource</code>, which is the default source created by the outbound adapter.
You can inject a different <code>SqlParameterSourceFactory</code> to get different behavior.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The outbound adapter requires a reference to either a <code>DataSource</code> or a <code>JdbcTemplate</code>.
You can also inject a <code>SqlParameterSourceFactory</code> to control the binding of each incoming message to a query.</p>
</div>
<div class="paragraph">
<p>If the input channel is a direct channel, the outbound adapter runs its query in the same thread and, therefore, the same transaction (if there is one) as the sender of the message.</p>
</div>
<div class="sect3">
<h4 id="passing-parameters-by-using-spel-expressions"><a class="anchor" href="#passing-parameters-by-using-spel-expressions"></a>Passing Parameters by Using SpEL Expressions</h4>
<div class="paragraph">
<p>A common requirement for most JDBC channel adapters is to pass parameters as part of SQL queries or stored procedures or functions.
As mentioned earlier, these parameters are by default bean property expressions, not SpEL expressions.
However, if you need to pass SpEL expression as parameters, you must explicitly inject a <code>SqlParameterSourceFactory</code>.</p>
</div>
<div class="paragraph">
<p>The following example uses a <code>ExpressionEvaluatingSqlParameterSourceFactory</code> to achieve that requirement:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;jdbc:outbound-channel-adapter data-source="dataSource" channel="input"
    query="insert into MESSAGES (MESSAGE_ID,PAYLOAD,CREATED_DATE)     \
    values (:id, :payload, :createdDate)"
    sql-parameter-source-factory="spelSource"/&gt;

&lt;bean id="spelSource"
      class="o.s.integration.jdbc.ExpressionEvaluatingSqlParameterSourceFactory"&gt;
    &lt;property name="parameterExpressions"&gt;
        &lt;map&gt;
            &lt;entry key="id"          value="headers['id'].toString()"/&gt;
            &lt;entry key="createdDate" value="new java.util.Date()"/&gt;
            &lt;entry key="payload"     value="payload"/&gt;
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>For further information, see <a href="#sp-defining-parameter-sources">Defining Parameter Sources</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="using-the-preparedstatement-callback"><a class="anchor" href="#using-the-preparedstatement-callback"></a>Using the <code>PreparedStatement</code> Callback</h4>
<div class="paragraph">
<p>Sometimes, the flexibility and loose-coupling of <code>SqlParameterSourceFactory</code> does not do what we need for the target <code>PreparedStatement</code> or we need to do some low-level JDBC work.
The Spring JDBC module provides APIs to configure the execution environment (such as <code>ConnectionCallback</code> or <code>PreparedStatementCreator</code>) and manipulate parameter values (such as <code>SqlParameterSource</code>).
It can even access APIs for low-level operations, such as <code>StatementCallback</code>.</p>
</div>
<div class="paragraph">
<p>Starting with Spring Integration 4.2, <code>MessagePreparedStatementSetter</code> allows the specification of parameters on the <code>PreparedStatement</code> manually, in the <code>requestMessage</code> context.
This class plays exactly the same role as <code>PreparedStatementSetter</code> in the standard Spring JDBC API.
Actually, it is invoked directly from an inline <code>PreparedStatementSetter</code> implementation when the <code>JdbcMessageHandler</code> invokes <code>execute</code> on the <code>JdbcTemplate</code>.</p>
</div>
<div class="paragraph">
<p>This functional interface option is mutually exclusive with <code>sqlParameterSourceFactory</code> and can be used as a more powerful alternative to populate parameters of the <code>PreparedStatement</code> from the <code>requestMessage</code>.
For example, it is useful when we need to store <code>File</code> data to the DataBase <code>BLOB</code> column in a streaming manner.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Bean
@ServiceActivator(inputChannel = "storeFileChannel")
public MessageHandler jdbcMessageHandler(DataSource dataSource) {
    JdbcMessageHandler jdbcMessageHandler = new JdbcMessageHandler(dataSource,
            "INSERT INTO imagedb (image_name, content, description) VALUES (?, ?, ?)");
    jdbcMessageHandler.setPreparedStatementSetter((ps, m) -&gt; {
        ps.setString(1, m.getHeaders().get(FileHeaders.FILENAME));
        try (FileInputStream inputStream = new FileInputStream((File) m.getPayload()); ) {
            ps.setBlob(2, inputStream);
        }
        catch (Exception e) {
            throw new MessageHandlingException(m, e);
        }
        ps.setClob(3, new StringReader(m.getHeaders().get("description", String.class)));
    });
    return jdbcMessageHandler;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>From the XML configuration perspective, the <code>prepared-statement-setter</code> attribute is available on the <code>&lt;int-jdbc:outbound-channel-adapter&gt;</code> component.
It lets you specify a <code>MessagePreparedStatementSetter</code> bean reference.</p>
</div>
</div>
<div class="sect3">
<h4 id="batch-update"><a class="anchor" href="#batch-update"></a>Batch Update</h4>
<div class="paragraph">
<p>Starting with version 5.1, the <code>JdbcMessageHandler</code> performs a <code>JdbcOperations.batchUpdate()</code> if the payload of the request message is an <code>Iterable</code> instance.
Each element of the <code>Iterable</code> is wrapped to a <code>Message</code> with the headers from the request message.
In the case of regular <code>SqlParameterSourceFactory</code>-based configuration these messages are used to build an <code>SqlParameterSource[]</code> for an argument used in the mentioned <code>JdbcOperations.batchUpdate()</code> function.
When a <code>MessagePreparedStatementSetter</code> configuration is applied, a <code>BatchPreparedStatementSetter</code> variant is used to iterate over those messages for each item and the provided <code>MessagePreparedStatementSetter</code> is called against them.
The batch update is not supported when <code>keysGenerated</code> mode is selected.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jdbc-outbound-gateway"><a class="anchor" href="#jdbc-outbound-gateway"></a>Outbound Gateway</h3>
<div class="paragraph">
<p>The outbound gateway is like a combination of the outbound and inbound adapters: Its role is to handle a message and use it to execute a SQL query and then respond with the result by sending it to a reply channel.
By default, the message payload and headers are available as input parameters to the query, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;int-jdbc:outbound-gateway
    update="insert into mythings (id, status, name) values (:headers[id], 0, :payload[thing])"
    request-channel="input" reply-channel="output" data-source="dataSource" /&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The result of the preceding example is to insert a record into the <code>mythings</code> table and return a message that indicates the number of rows affected (the payload is a map: <code>{UPDATED=1}</code>) to the output channel .</p>
</div>
<div class="paragraph">
<p>If the update query is an insert with auto-generated keys, you can populate the reply message with the generated keys by adding <code>keys-generated="true"</code> to the preceding example (this is not the default because it is not supported by some database platforms).
The following example shows the changed configuration:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;int-jdbc:outbound-gateway
    update="insert into mythings (status, name) values (0, :payload[thing])"
    request-channel="input" reply-channel="output" data-source="dataSource"
    keys-generated="true"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Instead of the update count or the generated keys, you can also provide a select query to execute and generate a reply message from the result (such as the inbound adapter), as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;int-jdbc:outbound-gateway
    update="insert into foos (id, status, name) values (:headers[id], 0, :payload[foo])"
    query="select * from foos where id=:headers[$id]"
    request-channel="input" reply-channel="output" data-source="dataSource"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Since Spring Integration 2.2, the update SQL query is no longer mandatory.
You can now provide only a select query, by using either the <code>query</code> attribute or the <code>query</code> element.
This is extremely useful if you need to actively retrieve data by using, for example, a generic gateway or a payload enricher.
The reply message is then generated from the result (similar to how the inbound adapter works) and passed to the reply channel.
The following example show to use the <code>query</code> attribute:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;int-jdbc:outbound-gateway
    query="select * from foos where id=:headers[id]"
    request-channel="input"
    reply-channel="output"
    data-source="dataSource"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>By default, the component for the <code>SELECT</code> query returns only one (the first) row from the cursor.
You can adjust this behavior with the <code>max-rows</code> option.
If you need to return all the rows from the SELECT, consider specifying <code>max-rows="0"</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>As with the channel adapters, you can also provide <code>SqlParameterSourceFactory</code> instances for request and reply.
The default is the same as for the outbound adapter, so the request message is available as the root of an expression.
If <code>keys-generated="true"</code>, the root of the expression is the generated keys (a map if there is only one or a list of maps if multi-valued).</p>
</div>
<div class="paragraph">
<p>The outbound gateway requires a reference to either a <code>DataSource</code> or a <code>JdbcTemplate</code>.
It can also have a <code>SqlParameterSourceFactory</code> injected to control the binding of the incoming message to the query.</p>
</div>
<div class="paragraph">
<p>Starting with the version 4.2, the <code>request-prepared-statement-setter</code> attribute is available on the <code>&lt;int-jdbc:outbound-gateway&gt;</code> as an alternative to <code>request-sql-parameter-source-factory</code>.
It lets you specify a <code>MessagePreparedStatementSetter</code> bean reference, which implements more sophisticated <code>PreparedStatement</code> preparation before its execution.</p>
</div>
<div class="paragraph">
<p>See <a href="#jdbc-outbound-channel-adapter">Outbound Channel Adapter</a> for more information about <code>MessagePreparedStatementSetter</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="jdbc-message-store"><a class="anchor" href="#jdbc-message-store"></a>JDBC Message Store</h3>
<div class="paragraph">
<p>Spring Integration provides two JDBC specific message store implementations.
The <code>JdbcMessageStore</code> is suitable for use with aggregators and the claim check pattern.
The <code>JdbcChannelMessageStore</code> implementation provides a more targeted and scalable implementation specifically for message channel.</p>
</div>
<div class="paragraph">
<p>Note that you can use a <code>JdbcMessageStore</code> to back a message channel, <code>JdbcChannelMessageStore</code> is optimized for that purpose.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Starting with versions 5.0.11, 5.1.2, the indexes for the <code>JdbcChannelMessageStore</code> have been optimized.
If you have large message groups in such a store, you may wish to alter the indexes.
Furthermore, the index for <code>PriorityChannel</code> is commented out because it is not needed unless you are using such channels backed by JDBC.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When using the <code>OracleChannelMessageStoreQueryProvider</code>, the priority channel index <strong>must</strong> be added because it is included in a hint in the query.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="initializing-the-database"><a class="anchor" href="#initializing-the-database"></a>Initializing the Database</h4>
<div class="paragraph">
<p>Before starting to use JDBC message store components, you should provision a target database with the appropriate objects.</p>
</div>
<div class="paragraph">
<p>Spring Integration ships with some sample scripts that can be used to initialize a database.
In the <code>spring-integration-jdbc</code> JAR file, you can find scripts in the <code>org.springframework.integration.jdbc</code> package.
It provides an example create and an example drop script for a range of common database platforms.
A common way to use these scripts is to reference them in a <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/jdbc.html#jdbc-intializing-datasource">Spring JDBC data source initializer</a>.
Note that the scripts are provided as samples and as specifications of the the required table and column names.
You may find that you need to enhance them for production use (for, example, by adding index declarations).</p>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-message-store-generic"><a class="anchor" href="#jdbc-message-store-generic"></a>The Generic JDBC Message Store</h4>
<div class="paragraph">
<p>The JDBC module provides an implementation of the Spring Integration <code>MessageStore</code> (important in the claim check pattern) and <code>MessageGroupStore</code> (important in stateful patterns such as an aggregator) backed by a database.
Both interfaces are implemented by the <code>JdbcMessageStore</code>, and there is support for configuring store instances in XML, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;int-jdbc:message-store id="messageStore" data-source="dataSource"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can specify a <code>JdbcTemplate</code> instead of a <code>DataSource</code>.</p>
</div>
<div class="paragraph">
<p>The following example shows some other optional attributes:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;int-jdbc:message-store id="messageStore" data-source="dataSource"
    lob-handler="lobHandler" table-prefix="MY_INT_"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, we have specified a <code>LobHandler</code> for dealing with messages as large objects (which is often necessary for Oracle) and a prefix for the table names in the queries generated by the store.
The table name prefix defaults to <code>INT_</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-message-store-channels"><a class="anchor" href="#jdbc-message-store-channels"></a>Backing Message Channels</h4>
<div class="paragraph">
<p>If you intend to backing message channels with JDBC, we recommend using the <code>JdbcChannelMessageStore</code> implementation.
It works only in conjunction with Message Channels.</p>
</div>
<div class="sect4">
<h5 id="supported-databases"><a class="anchor" href="#supported-databases"></a>Supported Databases</h5>
<div class="paragraph">
<p>The <code>JdbcChannelMessageStore</code> uses database-specific SQL queries to retrieve messages from the database.
Therefore, you must set the <code>ChannelMessageStoreQueryProvider</code> property on the <code>JdbcChannelMessageStore</code>.
This <code>channelMessageStoreQueryProvider</code> provides the SQL queries for the particular database you specify.
Spring Integration provides support for the following relational databases:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>PostgreSQL</p>
</li>
<li>
<p>HSQLDB</p>
</li>
<li>
<p>MySQL</p>
</li>
<li>
<p>Oracle</p>
</li>
<li>
<p>Derby</p>
</li>
<li>
<p>H2</p>
</li>
<li>
<p>SqlServer</p>
</li>
<li>
<p>Sybase</p>
</li>
<li>
<p>DB2</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If your database is not listed, you can extend the <code>AbstractChannelMessageStoreQueryProvider</code> class and provide your own custom queries.</p>
</div>
<div class="paragraph">
<p>Version 4.0 added the <code>MESSAGE_SEQUENCE</code> column to the table to ensure first-in-first-out (FIFO) queueing even when messages are stored in the same millisecond.</p>
</div>
</div>
<div class="sect4">
<h5 id="custom-message-insertion"><a class="anchor" href="#custom-message-insertion"></a>Custom Message Insertion</h5>
<div class="paragraph">
<p>Since version 5.0, by overloading the <code>ChannelMessageStorePreparedStatementSetter</code> class, you can provide a custom implementation for message insertion in the <code>JdbcChannelMessageStore</code>.
You can use it to set different columns or change the table structure or serialization strategy.
For example, instead of default serialization to <code>byte[]</code>, you can store its structure as a JSON string.</p>
</div>
<div class="paragraph">
<p>The following example uses the default implementation of <code>setValues</code> to store common columns and overrides the behavior to store the message payload as a <code>varchar</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class JsonPreparedStatementSetter extends ChannelMessageStorePreparedStatementSetter {

    @Override
    public void setValues(PreparedStatement preparedStatement, Message&lt;?&gt; requestMessage,
        Object groupId, String region, 	boolean priorityEnabled) throws SQLException {
        // Populate common columns
        super.setValues(preparedStatement, requestMessage, groupId, region, priorityEnabled);
        // Store message payload as varchar
        preparedStatement.setString(6, requestMessage.getPayload().toString());
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Generally, we do not recommend using a relational database for queuing.
Instead, if possible, consider using either JMS- or AMQP-backed channels instead.
For further reference, see the following resources:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://www.engineyard.com/blog/2011/5-subtle-ways-youre-using-mysql-as-a-queue-and-why-itll-bite-you/">5 subtle ways you’re using MySQL as a queue, and why it’ll bite you</a>.</p>
</li>
<li>
<p><a href="https://mikehadlow.blogspot.com/2012/04/database-as-queue-anti-pattern.html">The Database As Queue Anti-Pattern</a>.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="concurrent-polling"><a class="anchor" href="#concurrent-polling"></a>Concurrent Polling</h5>
<div class="paragraph">
<p>When polling a message channel, you have the option to configure the associated <code>Poller</code> with a <code>TaskExecutor</code> reference.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Keep in mind, though, that if you use a JDBC backed message channel and you plan to poll the channel and consequently the message store transactionally with multiple threads, you should ensure that you use a relational database that supports <a href="https://en.wikipedia.org/wiki/Multiversion_concurrency_control">Multiversion Concurrency Control</a> (MVCC).
Otherwise, locking may be an issue and the performance, when using multiple threads, may not materialize as expected.
For example, Apache Derby is problematic in that regard.</p>
</div>
<div class="paragraph">
<p>To achieve better JDBC queue throughput and avoid issues when different threads may poll the same <code>Message</code> from the queue, it is <strong>important</strong> to set the <code>usingIdCache</code> property of <code>JdbcChannelMessageStore</code> to <code>true</code> when using databases that do not support MVCC.
The following example shows how to do so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="queryProvider"
    class="o.s.i.jdbc.store.channel.PostgresChannelMessageStoreQueryProvider"/&gt;

&lt;int:transaction-synchronization-factory id="syncFactory"&gt;
    &lt;int:after-commit expression="@store.removeFromIdCache(headers.id.toString())" /&gt;
    &lt;int:after-rollback expression="@store.removeFromIdCache(headers.id.toString())"/&gt;
&lt;/int:transaction-synchronization-factory&gt;

&lt;task:executor id="pool" pool-size="10"
    queue-capacity="10" rejection-policy="CALLER_RUNS" /&gt;

&lt;bean id="store" class="o.s.i.jdbc.store.JdbcChannelMessageStore"&gt;
    &lt;property name="dataSource" ref="dataSource"/&gt;
    &lt;property name="channelMessageStoreQueryProvider" ref="queryProvider"/&gt;
    &lt;property name="region" value="TX_TIMEOUT"/&gt;
    &lt;property name="usingIdCache" value="true"/&gt;
&lt;/bean&gt;

&lt;int:channel id="inputChannel"&gt;
    &lt;int:queue message-store="store"/&gt;
&lt;/int:channel&gt;

&lt;int:bridge input-channel="inputChannel" output-channel="outputChannel"&gt;
    &lt;int:poller fixed-delay="500" receive-timeout="500"
        max-messages-per-poll="1" task-executor="pool"&gt;
        &lt;int:transactional propagation="REQUIRED" synchronization-factory="syncFactory"
        isolation="READ_COMMITTED" transaction-manager="transactionManager" /&gt;
    &lt;/int:poller&gt;
&lt;/int:bridge&gt;

&lt;int:channel id="outputChannel" /&gt;</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="priority-channel"><a class="anchor" href="#priority-channel"></a>Priority Channel</h5>
<div class="paragraph">
<p>Starting with version 4.0, <code>JdbcChannelMessageStore</code> implements <code>PriorityCapableChannelMessageStore</code> and provides the <code>priorityEnabled</code> option, letting it be used as a <code>message-store</code> reference for <code>priority-queue</code> instances.
For this purpose, the <code>INT_CHANNEL_MESSAGE</code> table has a <code>MESSAGE_PRIORITY</code> column to store the value of <code>PRIORITY</code> message headers.
In addition, a new <code>MESSAGE_SEQUENCE</code> column lets us achieve a robust first-in-first-out (FIFO) polling mechanism, even when multiple messages are stored with the same priority in the same millisecond.
Messages are polled (selected) from the database with <code>order by MESSAGE_PRIORITY DESC NULLS LAST, CREATED_DATE, MESSAGE_SEQUENCE</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
We do not recommend using the same <code>JdbcChannelMessageStore</code> bean for priority and non-priority queue channels, because the <code>priorityEnabled</code> option applies to the entire store and proper FIFO queue semantics are not retained for the queue channel.
However, the same <code>INT_CHANNEL_MESSAGE</code> table (and even <code>region</code>) can be used for both <code>JdbcChannelMessageStore</code> types.
To configure that scenario, you can extend one message store bean from the other, as the following example shows:
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="channelStore" class="o.s.i.jdbc.store.JdbcChannelMessageStore"&gt;
    &lt;property name="dataSource" ref="dataSource"/&gt;
    &lt;property name="channelMessageStoreQueryProvider" ref="queryProvider"/&gt;
&lt;/bean&gt;

&lt;int:channel id="queueChannel"&gt;
    &lt;int:queue message-store="channelStore"/&gt;
&lt;/int:channel&gt;

&lt;bean id="priorityStore" parent="channelStore"&gt;
    &lt;property name="priorityEnabled" value="true"/&gt;
&lt;/bean&gt;

&lt;int:channel id="priorityChannel"&gt;
    &lt;int:priority-queue message-store="priorityStore"/&gt;
&lt;/int:channel&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="partitioning-a-message-store"><a class="anchor" href="#partitioning-a-message-store"></a>Partitioning a Message Store</h4>
<div class="paragraph">
<p>It is common to use a <code>JdbcMessageStore</code> as a global store for a group of applications or nodes in the same application.
To provide some protection against name clashes and to give control over the database meta-data configuration, the message store lets the tables be partitioned in two ways.
One way is to use separate table names, by changing the prefix (as <a href="#jdbc-message-store-generic">described earlier</a>).
The other way is to specify a <code>region</code> name for partitioning data within a single table.
An important use case for the second approach is when the <code>MessageStore</code> is managing persistent queues that back a Spring Integration Message Channel.
The message data for a persistent channel is keyed in the store on the channel name.
Consequently, if the channel names are not globally unique, the channels can pick up data that is not intended for them.
To avoid this danger, you can use the message store <code>region</code> to keep data separate for different physical channels that have the same logical name.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="stored-procedures"><a class="anchor" href="#stored-procedures"></a>Stored Procedures</h3>
<div class="paragraph">
<p>In certain situations, plain JDBC support is not sufficient.
Maybe you deal with legacy relational database schemas or you have complex data processing needs, but, ultimately, you have to use <a href="https://en.wikipedia.org/wiki/Stored_procedure">stored procedures</a> or stored functions.
Since Spring Integration 2.1, we provide three components to execute stored procedures or stored functions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Stored Procedures Inbound Channel Adapter</p>
</li>
<li>
<p>Stored Procedures Outbound Channel Adapter</p>
</li>
<li>
<p>Stored Procedures Outbound Gateway</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="sp-supported-databases"><a class="anchor" href="#sp-supported-databases"></a>Supported Databases</h4>
<div class="paragraph">
<p>In order to enable calls to stored procedures and stored functions, the stored procedure components use the <a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/jdbc/core/simple/SimpleJdbcCall.html"><code>org.springframework.jdbc.core.simple.SimpleJdbcCall</code></a> class.
Consequently, the following databases are fully supported for executing stored procedures:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Apache Derby</p>
</li>
<li>
<p>DB2</p>
</li>
<li>
<p>MySQL</p>
</li>
<li>
<p>Microsoft SQL Server</p>
</li>
<li>
<p>Oracle</p>
</li>
<li>
<p>PostgreSQL</p>
</li>
<li>
<p>Sybase</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If you want to execute stored functions instead, the following databases are fully supported:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>MySQL</p>
</li>
<li>
<p>Microsoft SQL Server</p>
</li>
<li>
<p>Oracle</p>
</li>
<li>
<p>PostgreSQL</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Even though your particular database may not be fully supported, chances are that you can use the stored procedure Spring Integration components quite successfully anyway, provided your RDBMS supports stored procedures or stored functions.</p>
</div>
<div class="paragraph">
<p>As a matter of fact, some of the provided integration tests use the <a href="https://www.h2database.com/">H2 database</a>.
Nevertheless, it is very important to thoroughly test those usage scenarios.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="sp-configuration"><a class="anchor" href="#sp-configuration"></a>Configuration</h4>
<div class="paragraph">
<p>The stored procedure components provide full XML Namespace support, and configuring the components is similar as for the general purpose JDBC components discussed earlier.</p>
</div>
</div>
<div class="sect3">
<h4 id="sp-common-config-params"><a class="anchor" href="#sp-common-config-params"></a>Common Configuration Attributes</h4>
<div class="paragraph">
<p>All stored procedure components share certain configuration parameters:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>auto-startup</code>: Lifecycle attribute signaling whether this component should be started during application context startup.
It defaults to <code>true</code>.
Optional.</p>
</li>
<li>
<p><code>data-source</code>: Reference to a <code>javax.sql.DataSource</code>, which is used to access the database.
Required.</p>
</li>
<li>
<p><code>id</code>: Identifies the underlying Spring bean definition, which is an instance of either <code>EventDrivenConsumer</code> or <code>PollingConsumer</code>, depending on whether the outbound channel adapter&#8217;s <code>channel</code> attribute references a <code>SubscribableChannel</code> or a <code>PollableChannel</code>.
Optional.</p>
</li>
<li>
<p><code>ignore-column-meta-data</code>: For fully supported databases, the underlying <a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/jdbc/core/simple/SimpleJdbcCall.html"><code>SimpleJdbcCall</code></a> class can automatically retrieve the parameter information for the stored procedure or stored function from the JDBC metadata.</p>
<div class="paragraph">
<p>However, if the database does not support metadata lookups or if you need to provide customized parameter definitions, this flag can be set to <code>true</code>.
It defaults to <code>false</code>.
Optional.</p>
</div>
</li>
<li>
<p><code>is-function</code>: If <code>true</code>, a SQL Function is called.
In that case, the <code>stored-procedure-name</code> or <code>stored-procedure-name-expression</code> attributes define the name of the called function.
It defaults to <code>false</code>.
Optional.</p>
</li>
<li>
<p><code>stored-procedure-name</code>: This attribute specifies the name of the stored procedure.
If the <code>is-function</code> attribute is set to <code>true</code>, this attribute specifies the function name instead.
Either this property or <code>stored-procedure-name-expression</code> must be specified.</p>
</li>
<li>
<p><code>stored-procedure-name-expression</code>: This attribute specifies the name of the stored procedure by using a SpEL expression.
By using SpEL, you have access to the full message (if available), including its headers and payload.
You can use this attribute to invoke different stored procedures at runtime.
For example, you can provide stored procedure names that you would like to execute as a message header.
The expression must resolve to a <code>String</code>.</p>
<div class="paragraph">
<p>If the <code>is-function</code> attribute is set to <code>true</code>, this attribute specifies a stored function.
Either this property or <code>stored-procedure-name</code> must be specified.</p>
</div>
</li>
<li>
<p><code>jdbc-call-operations-cache-size</code>: Defines the maximum number of cached <code>SimpleJdbcCallOperations</code> instances.
Basically, for each stored procedure name, a new <a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/jdbc/core/simple/SimpleJdbcCallOperations.html"><code>SimpleJdbcCallOperations</code></a> instance is created that, in return, is cached.</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring Integration 2.2 added the <code>stored-procedure-name-expression</code> attribute and the <code>jdbc-call-operations-cache-size</code> attribute.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The default cache size is <code>10</code>.
A value of <code>0</code> disables caching.
Negative values are not permitted.</p>
</div>
<div class="paragraph">
<p>If you enable JMX, statistical information about the <code>jdbc-call-operations-cache</code> is exposed as an MBean.
See <a href="./jmx.html#jmx-mbean-exporter">MBean Exporter</a> for more information.</p>
</div>
</li>
<li>
<p><code>sql-parameter-source-factory</code>: (Not available for the stored procedure inbound channel adapter.)
Reference to a <code>SqlParameterSourceFactory</code>.
By default, bean properties of the passed in <code>Message</code> payload are used as a source for the stored procedure&#8217;s input parameters by using a <code>BeanPropertySqlParameterSourceFactory</code>.</p>
<div class="paragraph">
<p>This may suffice for basic use cases.
For more sophisticated options, consider passing in one or more <code>ProcedureParameter</code> values.
See <a href="#sp-defining-parameter-sources">Defining Parameter Sources</a>.
Optional.</p>
</div>
</li>
<li>
<p><code>use-payload-as-parameter-source</code>: (Not available for the stored procedure inbound channel adapter.)
If set to <code>true</code>, the payload of the <code>Message</code> is used as a source for providing parameters.
If set to <code>false</code>, however, the entire <code>Message</code> is available as a source for parameters.</p>
<div class="paragraph">
<p>If no procedure parameters are passed in, this property defaults to <code>true</code>.
This means that, by using a default <code>BeanPropertySqlParameterSourceFactory</code>, the bean properties of the payload are used as a source for parameter values for the stored procedure or stored function.</p>
</div>
<div class="paragraph">
<p>However, if procedure parameters are passed in, this property (by default) evaluates to <code>false</code>.
<code>ProcedureParameter</code> lets SpEL Expressions be provided.
Therefore, it is highly beneficial to have access to the entire <code>Message</code>.
The property is set on the underlying <code>StoredProcExecutor</code>.
Optional.</p>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="sp-common-config-subelements"><a class="anchor" href="#sp-common-config-subelements"></a>Common Configuration Sub-Elements</h4>
<div class="paragraph">
<p>The stored procedure components share a common set of child elements that you can use to define and pass parameters to stored procedures or stored functions.
The following elements are available:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>parameter</code></p>
</li>
<li>
<p><code>returning-resultset</code></p>
</li>
<li>
<p><code>sql-parameter-definition</code></p>
</li>
<li>
<p><code>poller</code></p>
</li>
<li>
<p><code>parameter</code>: Provides a mechanism to provide stored procedure parameters.
Parameters can be either static or provided by using a SpEL Expressions.</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;int-jdbc:parameter name=""         <i class="conum" data-value="1"></i><b>(1)</b>
                    type=""         <i class="conum" data-value="2"></i><b>(2)</b>
                    value=""/&gt;      <i class="conum" data-value="3"></i><b>(3)</b>

&lt;int-jdbc:parameter name=""
                    expression=""/&gt; <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="paragraph">
<p>+
&lt;1&gt; The name of the parameter to be passed into the Stored Procedure or Stored Function.
Required.
&lt;2&gt; This attribute specifies the type of the value.
If nothing is provided, this attribute defaults to <code>java.lang.String</code>.
This attribute is used only when the <code>value</code> attribute is used.
Optional.
&lt;3&gt; The value of the parameter.
You must provide either this attribute or the <code>expression</code> attribute.
Optional.
&lt;4&gt; Instead of the <code>value</code> attribute, you can specify a SpEL expression for passing the value of the parameter.
If you specify the <code>expression</code>, the <code>value</code> attribute is not allowed.
Optional.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Optional.</p>
</div>
</li>
<li>
<p><code>returning-resultset</code>: Stored procedures may return multiple result sets.
By setting one or more <code>returning-resultset</code> elements, you can specify <code>RowMappers</code> to convert each returned <code>ResultSet</code> to meaningful objects.
Optional.</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;int-jdbc:returning-resultset name="" row-mapper="" /&gt;</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p><code>sql-parameter-definition</code>: If you use a database that is fully supported, you typically do not have to specify the stored procedure parameter definitions.
Instead, those parameters can be automatically derived from the JDBC metadata.
However, if you use databases that are not fully supported, you must set those parameters explicitly by using the <code>sql-parameter-definition</code> element.</p>
<div class="paragraph">
<p>You can also choose to turn off any processing of parameter metadata information obtained through JDBC by using the <code>ignore-column-meta-data</code> attribute.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;int-jdbc:sql-parameter-definition
                                   name=""                           <i class="conum" data-value="1"></i><b>(1)</b>
                                   direction="IN"                    <i class="conum" data-value="2"></i><b>(2)</b>
                                   type="STRING"                     <i class="conum" data-value="3"></i><b>(3)</b>
                                   scale="5"                         <i class="conum" data-value="4"></i><b>(4)</b>
                                   type-name="FOO_STRUCT"            <i class="conum" data-value="5"></i><b>(5)</b>
                                   return-type="fooSqlReturnType"/&gt;  <i class="conum" data-value="6"></i><b>(6)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Specifies the name of the SQL parameter.
Required.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Specifies the direction of the SQL parameter definition.
Defaults to <code>IN</code>.
Valid values are: <code>IN</code>, <code>OUT</code>, and <code>INOUT</code>.
If your procedure is returning result sets, use the <code>returning-resultset</code> element.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The SQL type used for this SQL parameter definition.
Translates into an integer value, as defined by <code>java.sql.Types</code>.
Alternatively, you can provide the integer value as well.
If this attribute is not explicitly set, it defaults to 'VARCHAR'.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The scale of the SQL parameter.
Only used for numeric and decimal parameters.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>The <code>typeName</code> for types that are user-named, such as: <code>STRUCT</code>, <code>DISTINCT</code>, <code>JAVA_OBJECT</code>, and named array types.
This attribute is mutually exclusive with the <code>scale</code> attribute.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>The reference to a custom value handler for complex types.
An implementation of <a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/jdbc/core/SqlReturnType.html"><code>SqlReturnType</code></a>.
This attribute is mutually exclusive with the <code>scale</code> attribute and is only applicable for OUT and INOUT parameters.
Optional.</td>
</tr>
</table>
</div>
</div>
</div>
</li>
<li>
<p><code>poller</code>: Lets you configure a message poller if this endpoint is a <code>PollingConsumer</code>.
Optional.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="sp-defining-parameter-sources"><a class="anchor" href="#sp-defining-parameter-sources"></a>Defining Parameter Sources</h4>
<div class="paragraph">
<p>Parameter sources govern the techniques of retrieving and mapping the Spring Integration message properties to the relevant stored procedure input parameters.</p>
</div>
<div class="paragraph">
<p>The stored procedure components follow certain rules.
By default, the bean properties of the <code>Message</code> payload are used as a source for the stored procedure&#8217;s input parameters.
In that case, a <code>BeanPropertySqlParameterSourceFactory</code> is used.
This may suffice for basic use cases.
The next example illustrates that default behavior.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
For the &#8220;automatic&#8221; lookup of bean properties by using the <code>BeanPropertySqlParameterSourceFactory</code> to work, your bean properties must be defined in lower case.
This is due to the fact that in <code>org.springframework.jdbc.core.metadata.CallMetaDataContext</code> (the Java method is <code>matchInParameterValuesWithCallParameters()</code>), the retrieved stored procedure parameter declarations are converted to lower case.
As a result, if you have camel-case bean properties (such as <code>lastName</code>), the lookup fails.
In that case, provide an explicit <code>ProcedureParameter</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Suppose we have a payload that consists of a simple bean with the following three properties: <code>id</code>, <code>name</code>, and <code>description</code>.
Furthermore, we have a simplistic Stored Procedure called <code>INSERT_COFFEE</code> that accepts three input parameters: <code>id</code>, <code>name</code>, and <code>description</code>.
We also use a fully supported database.
In that case, the following configuration for a stored procedure outbound adapter suffices:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;int-jdbc:stored-proc-outbound-channel-adapter data-source="dataSource"
    channel="insertCoffeeProcedureRequestChannel"
    stored-procedure-name="INSERT_COFFEE"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>For more sophisticated options, consider passing in one or more <code>ProcedureParameter</code> values.</p>
</div>
<div class="paragraph">
<p>If you do provide <code>ProcedureParameter</code> values explicitly, by default, an <code>ExpressionEvaluatingSqlParameterSourceFactory</code> is used for parameter processing, to enable the full power of SpEL expressions.</p>
</div>
<div class="paragraph">
<p>If you need even more control over how parameters are retrieved, consider passing in a custom implementation of <code>SqlParameterSourceFactory</code> by using the <code>sql-parameter-source-factory</code> attribute.</p>
</div>
</div>
<div class="sect3">
<h4 id="stored-procedure-inbound-channel-adapter"><a class="anchor" href="#stored-procedure-inbound-channel-adapter"></a>Stored Procedure Inbound Channel Adapter</h4>
<div class="paragraph">
<p>The following listing calls out the attributes that matter for a stored procedure inbound channel adapter:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;int-jdbc:stored-proc-inbound-channel-adapter
                                   channel=""                                    <i class="conum" data-value="1"></i><b>(1)</b>
                                   stored-procedure-name=""
                                   data-source=""
                                   auto-startup="true"
                                   id=""
                                   ignore-column-meta-data="false"
                                   is-function="false"
                                   skip-undeclared-results=""                    <i class="conum" data-value="2"></i><b>(2)</b>
                                   return-value-required="false"                 <i class="conum" data-value="3"></i><b>(3)</b>
    &lt;int:poller/&gt;
    &lt;int-jdbc:sql-parameter-definition name="" direction="IN"
                                               type="STRING"
                                               scale=""/&gt;
    &lt;int-jdbc:parameter name="" type="" value=""/&gt;
    &lt;int-jdbc:parameter name="" expression=""/&gt;
    &lt;int-jdbc:returning-resultset name="" row-mapper="" /&gt;
&lt;/int-jdbc:stored-proc-inbound-channel-adapter&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Channel to which polled messages are sent.
If the stored procedure or function does not return any data, the payload of the <code>Message</code> is null.
Required.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>If this attribute is set to <code>true</code>, all results from a stored procedure call that do not have a corresponding <code>SqlOutParameter</code> declaration are bypassed.
For example, stored procedures can return an update count value, even though your stored procedure declared only a single result parameter.
The exact behavior depends on the database implementation.
The value is set on the underlying <code>JdbcTemplate</code>.
The value defaults to <code>true</code>.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Indicates whether this procedure&#8217;s return value should be included.
Since Spring Integration 3.0.
Optional.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="stored-procedure-outbound-channel-adapter"><a class="anchor" href="#stored-procedure-outbound-channel-adapter"></a>Stored Procedure Outbound Channel Adapter</h4>
<div class="paragraph">
<p>The following listing calls out the attributes that matter for a stored procedure outbound channel adapter:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;int-jdbc:stored-proc-outbound-channel-adapter channel=""                        <i class="conum" data-value="1"></i><b>(1)</b>
                                               stored-procedure-name=""
                                               data-source=""
                                               auto-startup="true"
                                               id=""
                                               ignore-column-meta-data="false"
                                               order=""                          <i class="conum" data-value="2"></i><b>(2)</b>
                                               sql-parameter-source-factory=""
                                               use-payload-as-parameter-source=""&gt;
    &lt;int:poller fixed-rate=""/&gt;
    &lt;int-jdbc:sql-parameter-definition name=""/&gt;
    &lt;int-jdbc:parameter name=""/&gt;

&lt;/int-jdbc:stored-proc-outbound-channel-adapter&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The receiving message channel of this endpoint.
Required.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Specifies the order for invocation when this endpoint is connected as a subscriber to a channel.
This is particularly relevant when that channel is using a <code>failover</code> dispatching strategy.
It has no effect when this endpoint is itself a polling consumer for a channel with a queue.
Optional.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="stored-procedure-outbound-gateway"><a class="anchor" href="#stored-procedure-outbound-gateway"></a>Stored Procedure Outbound Gateway</h4>
<div class="paragraph">
<p>The following listing calls out the attributes that matter for a stored procedure outbound channel adapter:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;int-jdbc:stored-proc-outbound-gateway request-channel=""                        <i class="conum" data-value="1"></i><b>(1)</b>
                                       stored-procedure-name=""
                                       data-source=""
                                   auto-startup="true"
                                   id=""
                                   ignore-column-meta-data="false"
                                   is-function="false"
                                   order=""
                                   reply-channel=""                              <i class="conum" data-value="2"></i><b>(2)</b>
                                   reply-timeout=""                              <i class="conum" data-value="3"></i><b>(3)</b>
                                   return-value-required="false"                 <i class="conum" data-value="4"></i><b>(4)</b>
                                   skip-undeclared-results=""                    <i class="conum" data-value="5"></i><b>(5)</b>
                                   sql-parameter-source-factory=""
                                   use-payload-as-parameter-source=""&gt;
&lt;int-jdbc:sql-parameter-definition name="" direction="IN"
                                   type=""
                                   scale="10"/&gt;
&lt;int-jdbc:sql-parameter-definition name=""/&gt;
&lt;int-jdbc:parameter name="" type="" value=""/&gt;
&lt;int-jdbc:parameter name="" expression=""/&gt;
&lt;int-jdbc:returning-resultset name="" row-mapper="" /&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The receiving message channel of this endpoint.
Required.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Message channel to which replies should be sent after receiving the database response.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Lets you specify how long this gateway waits for the reply message to be sent successfully before throwing an exception.
Keep in mind that, when sending to a <code>DirectChannel</code>, the invocation occurs in the sender&#8217;s thread.
Consequently, the failing of the send operation may be caused by other components further downstream.
By default, the gateway waits indefinitely.
The value is specified in milliseconds.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Indicates whether this procedure&#8217;s return value should be included.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>If the <code>skip-undeclared-results</code> attribute is set to <code>true</code>, all results from a stored procedure call that do not have a corresponding <code>SqlOutParameter</code> declaration are bypassed.
For example, stored procedures may return an update count value, even though your stored procedure only declared a single result parameter.
The exact behavior depends on the database.
The value is set on the underlying <code>JdbcTemplate</code>.
The value defaults to <code>true</code>.
Optional.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sp-examples"><a class="anchor" href="#sp-examples"></a>Examples</h4>
<div class="paragraph">
<p>This section contains two examples that call <a href="https://db.apache.org/derby/">Apache Derby</a> stored procedures.
The first procedure calls a stored procedure that returns a <code>ResultSet</code>.
By using a <code>RowMapper</code>, the data is converted into a domain object, which then becomes the Spring Integration message payload.</p>
</div>
<div class="paragraph">
<p>In the second sample, we call a stored procedure that uses output parameters to return data instead.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Have a look at the <a href="https://github.com/spring-projects/spring-integration-samples">Spring Integration Samples project</a>.</p>
</div>
<div class="paragraph">
<p>The project contains the Apache Derby example referenced here, as well as instructions on how to run it.
The Spring Integration Samples project also provides an <a href="https://github.com/spring-projects/spring-integration-samples/tree/master/intermediate/stored-procedures-oracle">example</a> of using Oracle stored procedures.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In the first example, we call a stored procedure named <code>FIND_ALL_COFFEE_BEVERAGES</code> that does not define any input parameters but that returns a <code>ResultSet</code>.</p>
</div>
<div class="paragraph">
<p>In Apache Derby, stored procedures are implemented in Java.
The following listing shows the method signature:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public static void findAllCoffeeBeverages(ResultSet[] coffeeBeverages)
            throws SQLException {
    ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following listing shows the corresponding SQL:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="sql" class="language-sql hljs">CREATE PROCEDURE FIND_ALL_COFFEE_BEVERAGES() \
PARAMETER STYLE JAVA LANGUAGE JAVA MODIFIES SQL DATA DYNAMIC RESULT SETS 1 \
EXTERNAL NAME 'o.s.i.jdbc.storedproc.derby.DerbyStoredProcedures.findAllCoffeeBeverages';</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In Spring Integration, you can now call this stored procedure by using, for example, a <code>stored-proc-outbound-gateway</code>, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;int-jdbc:stored-proc-outbound-gateway id="outbound-gateway-storedproc-find-all"
                                       data-source="dataSource"
                                       request-channel="findAllProcedureRequestChannel"
                                       expect-single-result="true"
                                       stored-procedure-name="FIND_ALL_COFFEE_BEVERAGES"&gt;
&lt;int-jdbc:returning-resultset name="coffeeBeverages"
    row-mapper="org.springframework.integration.support.CoffeBeverageMapper"/&gt;
&lt;/int-jdbc:stored-proc-outbound-gateway&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the second example, we call a stored procedure named <code>FIND_COFFEE</code> that has one input parameter.
Instead of returning a <code>ResultSet</code>, it uses an output parameter.
The following example shows the method signature:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public static void findCoffee(int coffeeId, String[] coffeeDescription)
            throws SQLException {
    ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following listing shows the corresponding SQL:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="sql" class="language-sql hljs">CREATE PROCEDURE FIND_COFFEE(IN ID INTEGER, OUT COFFEE_DESCRIPTION VARCHAR(200)) \
PARAMETER STYLE JAVA LANGUAGE JAVA EXTERNAL NAME \
'org.springframework.integration.jdbc.storedproc.derby.DerbyStoredProcedures.findCoffee';</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In Spring Integration, you can now call this Stored Procedure by using, for example, a <code>stored-proc-outbound-gateway</code>, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;int-jdbc:stored-proc-outbound-gateway id="outbound-gateway-storedproc-find-coffee"
                                       data-source="dataSource"
                                       request-channel="findCoffeeProcedureRequestChannel"
                                       skip-undeclared-results="true"
                                       stored-procedure-name="FIND_COFFEE"
                                       expect-single-result="true"&gt;
    &lt;int-jdbc:parameter name="ID" expression="payload" /&gt;
&lt;/int-jdbc:stored-proc-outbound-gateway&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jdbc-lock-registry"><a class="anchor" href="#jdbc-lock-registry"></a>JDBC Lock Registry</h3>
<div class="paragraph">
<p>Version 4.3 introduced the <code>JdbcLockRegistry</code>.
Certain components (for example, aggregator and resequencer) use a lock obtained from a <code>LockRegistry</code> instance to ensure that only one thread manipulates a group at a time.
The <code>DefaultLockRegistry</code> performs this function within a single component.
You can now configure an external lock registry on these components.
When used with a shared <code>MessageGroupStore</code>, you can use the <code>JdbcLockRegistry</code> to provide this functionality across multiple application instances, such that only one instance can manipulate the group at a time.</p>
</div>
<div class="paragraph">
<p>When a lock is released by a local thread, another local thread can generally acquire the lock immediately.
If a lock is released by a thread that uses a different registry instance, it can take up to 100ms to acquire the lock.</p>
</div>
<div class="paragraph">
<p>The <code>JdbcLockRegistry</code> is based on the <code>LockRepository</code> abstraction, which has a <code>DefaultLockRepository</code> implementation.
The database schema scripts are located in the <code>org.springframework.integration.jdbc</code> package, which is divided for the particular RDBMS vendors.
For example, the following listing shows the H2 DDL for the lock table:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="sql" class="language-sql hljs">CREATE TABLE INT_LOCK  (
    LOCK_KEY CHAR(36),
    REGION VARCHAR(100),
    CLIENT_ID CHAR(36),
    CREATED_DATE TIMESTAMP NOT NULL,
    constraint INT_LOCK_PK primary key (LOCK_KEY, REGION)
);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>INT_</code> can be changed according to the target database design requirements.
Therefore, you must use <code>prefix</code> property on the <code>DefaultLockRepository</code> bean definition.</p>
</div>
<div class="paragraph">
<p>Sometimes, one application has moved to such a state that it cannot release the distributed lock and remove the particular record in the database.
For this purpose, such dead locks can be expired by the other application on the next locking invocation.
The <code>timeToLive</code> (TTL) option on the <code>DefaultLockRepository</code> is provided for this purpose.
You may also want to specify <code>CLIENT_ID</code> for the locks stored for a given <code>DefaultLockRepository</code> instance.
If so, you can specify the <code>id</code> to be associated with the <code>DefaultLockRepository</code> as a constructor parameter.</p>
</div>
<div class="paragraph">
<p>Starting with version 5.1.8, the <code>JdbcLockRegistry</code> can be configured with the <code>idleBetweenTries</code> - a <code>Duration</code> to sleep between lock record insert/update executions.
By default it is <code>100</code> milliseconds and in some environments non-leaders pollute connections with data source too often.</p>
</div>
</div>
<div class="sect2">
<h3 id="jdbc-metadata-store"><a class="anchor" href="#jdbc-metadata-store"></a>JDBC Metadata Store</h3>
<div class="paragraph">
<p>Version 5.0 introduced the JDBC <code>MetadataStore</code> (see <a href="./meta-data-store.html#metadata-store">Metadata Store</a>) implementation.
You can use the <code>JdbcMetadataStore</code> to maintain the metadata state across application restarts.
This <code>MetadataStore</code> implementation can be used with adapters such as the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="./feed.html#feed-inbound-channel-adapter">Feed inbound channel adapters</a></p>
</li>
<li>
<p><a href="./file.html#file-reading">File inbound channel adapters</a></p>
</li>
<li>
<p><a href="./ftp.html#ftp-inbound">FTP inbound channel adapters</a></p>
</li>
<li>
<p><a href="./sftp.html#sftp-inbound">SFTP inbound channel adapters</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To configure these adapters to use the <code>JdbcMetadataStore</code>, declare a Spring bean by using a bean name of <code>metadataStore</code>.
The Feed inbound channel adapter and the feed inbound channel adapter both automatically pick up and use the declared <code>JdbcMetadataStore</code>, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Bean
public MetadataStore metadataStore(DataSource dataSource) {
    return new JdbcMetadataStore(dataSource);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>org.springframework.integration.jdbc</code> package has Database schema scripts for several RDMBS vendors.
For example, the following listing shows the H2 DDL for the metadata table:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="sql" class="language-sql hljs">CREATE TABLE INT_METADATA_STORE  (
	METADATA_KEY VARCHAR(255) NOT NULL,
	METADATA_VALUE VARCHAR(4000),
	REGION VARCHAR(100) NOT NULL,
	constraint INT_METADATA_STORE_PK primary key (METADATA_KEY, REGION)
);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can change the <code>INT_</code> prefix to match the target database design requirements.
You can also configure <code>JdbcMetadataStore</code> to use the custom prefix.</p>
</div>
<div class="paragraph">
<p>The <code>JdbcMetadataStore</code> implements <code>ConcurrentMetadataStore</code>, letting it be reliably shared across multiple application instances, where only one instance can store or modify a key&#8217;s value.
All of these operations are atomic, thanks to transaction guarantees.</p>
</div>
<div class="paragraph">
<p>Transaction management must use <code>JdbcMetadataStore</code>.
Inbound channel adapters can be supplied with a reference to the <code>TransactionManager</code> in the poller configuration.
Unlike non-transactional <code>MetadataStore</code> implementations, with <code>JdbcMetadataStore</code>, the entry appears in the target table only after the transaction commits.
When a rollback occurs, no entries are added to the <code>INT_METADATA_STORE</code> table.</p>
</div>
<div class="paragraph">
<p>Since version 5.0.7, you can configure the <code>JdbcMetadataStore</code> with the RDBMS vendor-specific <code>lockHint</code> option for lock-based queries on metadata store entries.
By default, it is <code>FOR UPDATE</code> and can be configured with an empty string if the target database does not support row locking functionality.
Consult with your vendor for particular and possible hints in the <code>SELECT</code> expression for locking rows before updates.</p>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 5.3.2.RELEASE<br>
Last updated 2020-07-22 17:49:12 UTC
</div>
</div>
<link rel="stylesheet" href="js/highlight/styles/github.min.css">
<script src="js/highlight/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>
<script type="text/javascript" src="js/tocbot/tocbot.min.js"></script>
<script type="text/javascript" src="js/toc.js"></script>
<script>if(window.parent==window){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-2728886-23','auto',{'siteSpeedSampleRate':100});ga('send','pageview');}</script></body>
</html>